/*
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 *
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */


#define pr_fmt(fmt) "%s:%s: " fmt, KBUILD_MODNAME, __func__

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/stat.h>
#include <linux/slab.h>
#include <linux/proc_fs.h>
#include <linux/delay.h>
#include <linux/vmalloc.h>
#include <linux/mm.h>
#include <linux/highmem.h>


MODULE_AUTHOR("Sander Wiebing");
MODULE_DESCRIPTION("Intra-mode BTI Testing");
MODULE_LICENSE("GPL");

#define MODULE_MAPPING_START 0xffffffffc0000000 // 0xffffffffc0000000
#define MODULE_MAPPING_END   0xfffffffffeffffff

#define PAGE_2MB 1 << 21 // 2 MB

__always_inline static void cpuid_fence(void) { asm volatile ("xor %%rax, %%rax\ncpuid\n\t" ::: "%rax", "%rbx", "%rcx", "%rdx"); }
__always_inline static void flush(void * addr) { asm volatile ("clflush (%0)\n\t" :: "r"(addr):); }
__always_inline static void mfence(void) { asm volatile ("mfence\n\t":::); }
__always_inline static void lfence(void) { asm volatile ("lfence\n\t":::); }
__always_inline static void sfence(void) { asm volatile ("sfence\n\t":::); }




int is_address_mapped(void *virt_addr)
{
	unsigned long va = (unsigned long)virt_addr;
	unsigned long *r = NULL;
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;

	pgd = pgd_offset(current->mm, va);
	if (pgd_none(*pgd) || pgd_bad(*pgd))
		return 0;

	p4d = p4d_offset(pgd, va);
	if (p4d_none(*p4d) || p4d_bad(*p4d))
		return 0;

	pud = pud_offset(p4d, va);
	if (pud_none(*pud))
		return 0;

	if (pud_bad(*pud))
		return 0;


	pmd = pmd_offset(pud, va);
	if (pmd_none(*pmd))
		return 0;


	if (pmd_trans_huge(*pmd)) {
        pr_info("Huge page!\n");
		return 2;
	}


	if (pmd_bad(*pmd))
		return 0;


	pte = pte_offset_kernel(pmd, va);
	if (!pte_none(*pte)) {
		r = (unsigned long *)pte;
	}

	pte_unmap(pte);

    if (r) {
        return 1;
    }

	return 0;
}


static ssize_t mod_get_mapped_module_regions(struct file *filp, char *buf, size_t len, loff_t *off)
{
    char kbuf[256];
    uint64_t kern_address;
    int write_len = 0;
    int ret;
    int is_huge_page = 0;
    // uint64_t value;

    uint64_t region_start;
    uint64_t region_size;
    uint64_t n_regions = 0;

    if (*off != 0) {
        return 0;
    }

    pr_info("MODULE_MAPPING_START: %lx MODULE_MAPPING_END: %lx\n", MODULE_MAPPING_START, MODULE_MAPPING_END);

    region_start = 0;
    region_size = 0;

    for (kern_address = MODULE_MAPPING_START; kern_address < MODULE_MAPPING_END; kern_address += PAGE_SIZE)
    {
        ret = is_address_mapped((void *) kern_address);
        if (ret != 0) {

            if (region_start + region_size == kern_address) {
                if (ret == 1) {
                    region_size += PAGE_SIZE;
                } else {
                    is_huge_page = 1;
                    region_size += PAGE_2MB;
                }

            } else {
                if (region_start != 0) {
                    n_regions += 1;
                    if (is_huge_page) {
                       pr_info("%llx - %llx  %6llx HUGE\n", region_start, region_start + region_size, region_size);
                    } else {
                       pr_info("%llx - %llx  %llx\n", region_start, region_start + region_size, region_size);
                    }
                }

                // start a new region
                region_start = kern_address;
                if (ret == 1) {
                    is_huge_page = 0;
                    region_size = PAGE_SIZE;
                } else {
                    is_huge_page = 1;
                    region_size = PAGE_2MB;
                }
            }
        }
    }

    if (region_start != 0) {
        n_regions += 1;
        if (is_huge_page) {
            pr_info("%llx - %llx  %6llx HUGE\n", region_start, region_start + region_size, region_size);
        } else {
            pr_info("%llx - %llx  %llx\n", region_start, region_start + region_size, region_size);
        }
    }

    pr_info("Total mapped regions: %llu\n", n_regions);

    kbuf[0] = 'X';
    kbuf[1] = '\n';
    kbuf[2] = '\0';
    write_len = min(len, strlen(kbuf));
    *off += write_len;

    if (copy_to_user(buf, kbuf, write_len)) {
        return -EFAULT;
    }

	return write_len;


}

static ssize_t mod_get_last_module_region(struct file *filp, char *buf, size_t len, loff_t *off)
{
    char kbuf[256];
    uint64_t kern_address;
    int write_len = 0;
    int ret;
    int is_huge_page = 0;
    // uint64_t value;

    uint64_t region_start;
    uint64_t region_size;

    if (*off != 0) {
        return 0;
    }

    region_start = 0;
    region_size = 0;

    for (kern_address = MODULE_MAPPING_START; kern_address < MODULE_MAPPING_END; kern_address += PAGE_SIZE)
    {
        ret = is_address_mapped((void *) kern_address);
        if (ret != 0) {

            if (region_start + region_size == kern_address) {
                if (ret == 1) {
                    region_size += PAGE_SIZE;
                } else {
                    is_huge_page = 1;
                    region_size += PAGE_2MB;
                }

            } else {

                // start a new region
                region_start = kern_address;
                if (ret == 1) {
                    is_huge_page = 0;
                    region_size = PAGE_SIZE;
                } else {
                    is_huge_page = 1;
                    region_size = PAGE_2MB;
                }
            }
        }
    }


    snprintf(kbuf, 64, "0x%llx 0x%llx\n", region_start, region_size);

    write_len = min(len, strlen(kbuf));
    *off += write_len;

    if (copy_to_user(buf, kbuf, write_len)) {
        return -EFAULT;
    }

	return write_len;


}


static ssize_t mod_get_phys_map_start(struct file *filp, char *buf, size_t len, loff_t *off)
{
    char kbuf[256];
    uint64_t kern_address;
    int write_len = 0;

    if (*off != 0) {
        return 0;
    }

    snprintf(kbuf, 32, "%llx\n", (uint64_t) page_offset_base);

    write_len = min(len, strlen(kbuf));
    *off += write_len;

    if (copy_to_user(buf, kbuf, write_len)) {
        return -EFAULT;
    }

	return write_len;


}


static struct proc_ops get_mapped_module_regions_fops = {
	.proc_read = mod_get_mapped_module_regions
};

static struct proc_ops get_last_module_region_fops = {
	.proc_read = mod_get_last_module_region
};


static struct proc_ops phys_map_start_fops = {
	.proc_read = mod_get_phys_map_start
};

static struct proc_dir_entry *proc_dir;


static int __init intra_bhi_init(void)
{


    // Create the proc dir
    proc_dir = proc_mkdir("intra_its_help", NULL);

    proc_create("mapped_module_regions", 0666, proc_dir, &get_mapped_module_regions_fops);
    proc_create("last_mapped_module_region", 0666, proc_dir, &get_last_module_region_fops);

    proc_create("phys_map_start", 0666, proc_dir, &phys_map_start_fops);


    pr_info("Initialized\n");

	return 0;
}

static void __exit intra_bhi_exit(void)
{
	pr_info("exiting\n");
    proc_remove(proc_dir);
}

module_init(intra_bhi_init);
module_exit(intra_bhi_exit);
